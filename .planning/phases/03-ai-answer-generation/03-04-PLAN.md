# Plan 03-04: Question Detection & Suggest Button UI

**Phase:** 3 - AI Answer Generation
**Wave:** 3
**Priority:** P0 (Must-Have)
**Estimated Duration:** 50 minutes

---

## Goal

Build the question detection system that identifies text fields suitable for AI assistance, and implement the "Suggest Answer" button UI with draft selection interface. Enables users to click a button on detected question fields, generate 3 AI drafts, cycle through options, and insert their chosen answer.

---

## Context

From CONTEXT.md:
- Essay detection: Character limit ≥500 chars triggers STAR outline
- Draft presentation: Sequential cycling with Next/Previous buttons
- Edit after insert: Users can switch between original 3 drafts AND regenerate new drafts
- Field type targeting: Determine which fields get button based on characteristics

From RESEARCH.md:
- Use multiple signals: label analysis, field type, character limits, question markers
- Show badge/icon indicating "Mock Mode" or "Powered by [Provider]"
- Consider watermark or footer in generated content
- Make it obvious whether mock or real AI is active

---

## Requirements Covered

- REQ-AI-01: Mock AI response system (UI)
- REQ-AI-02: User-provided API key support (provider indication)
- REQ-AI-04: Placeholder markers (visual treatment)
- REQ-AI-05: Essay question handling (detection logic)

---

## Tasks

### Task 1: Create Question Detection Logic
**File:** `src/lib/ai/question-detector.ts`
**Action:** Multi-signal question field detection

```typescript
import type { ATSType } from '@/types/ats'

export interface QuestionField {
  element: HTMLTextAreaElement | HTMLInputElement
  label: string
  confidence: number
  isEssay: boolean
  detectionSignals: string[]
}

export interface DetectionConfig {
  minCharLimit: number // 500 for essay detection
  minConfidence: number // 0.7 to show button
  questionKeywords: string[]
  essayKeywords: string[]
}

const DEFAULT_CONFIG: DetectionConfig = {
  minCharLimit: 500,
  minConfidence: 0.7,
  questionKeywords: [
    'why', 'how', 'what', 'describe', 'explain', 'tell us',
    'share', 'give an example', 'experience', 'challenge',
    'strength', 'weakness', 'motivated', 'interest', 'passion'
  ],
  essayKeywords: [
    'describe a time', 'tell us about', 'give an example',
    'share a story', 'explain how', 'walk us through'
  ]
}

/**
 * Detect question fields on the page
 */
export function detectQuestionFields(
  atsType: ATSType | null,
  config: DetectionConfig = DEFAULT_CONFIG
): QuestionField[] {
  const fields: QuestionField[] = []
  
  // Find all textarea and text input fields
  const textareas = Array.from(document.querySelectorAll('textarea'))
  const textInputs = Array.from(document.querySelectorAll('input[type="text"]'))
  
  const allFields = [...textareas, ...textInputs]
  
  for (const element of allFields) {
    const detection = analyzeField(element, atsType, config)
    
    if (detection.confidence >= config.minConfidence) {
      fields.push(detection)
    }
  }
  
  return fields
}

/**
 * Analyze a single field for question indicators
 */
function analyzeField(
  element: HTMLTextAreaElement | HTMLInputElement,
  atsType: ATSType | null,
  config: DetectionConfig
): QuestionField {
  const signals: string[] = []
  let score = 0
  
  // Signal 1: Field type (textarea more likely than input)
  if (element.tagName === 'TEXTAREA') {
    score += 0.3
    signals.push('textarea')
  } else {
    score += 0.1
    signals.push('text-input')
  }
  
  // Signal 2: Label analysis
  const label = getFieldLabel(element, atsType)
  const labelLower = label.toLowerCase()
  
  for (const keyword of config.questionKeywords) {
    if (labelLower.includes(keyword)) {
      score += 0.2
      signals.push(`keyword:${keyword}`)
      break // Only count once
    }
  }
  
  // Signal 3: Question mark in label
  if (label.includes('?')) {
    score += 0.2
    signals.push('question-mark')
  }
  
  // Signal 4: Character limit (longer fields more likely)
  const maxLength = element.maxLength
  if (maxLength > 0) {
    if (maxLength >= config.minCharLimit) {
      score += 0.2
      signals.push('long-limit')
    } else if (maxLength >= 200) {
      score += 0.1
      signals.push('medium-limit')
    }
  }
  
  // Signal 5: Placeholder text
  const placeholder = element.placeholder?.toLowerCase() || ''
  for (const keyword of config.questionKeywords) {
    if (placeholder.includes(keyword)) {
      score += 0.1
      signals.push('placeholder-keyword')
      break
    }
  }
  
  // Signal 6: Rows attribute (for textarea)
  if (element.tagName === 'TEXTAREA') {
    const rows = (element as HTMLTextAreaElement).rows
    if (rows >= 5) {
      score += 0.1
      signals.push('multi-row')
    }
  }
  
  // Determine if essay mode
  const isEssay = detectEssayMode(label, maxLength, config)
  
  return {
    element,
    label,
    confidence: Math.min(score, 1.0),
    isEssay,
    detectionSignals: signals
  }
}

/**
 * Get field label using multiple strategies
 */
function getFieldLabel(
  element: HTMLTextAreaElement | HTMLInputElement,
  atsType: ATSType | null
): string {
  // Strategy 1: Explicit label element
  const id = element.id
  if (id) {
    const label = document.querySelector(`label[for="${id}"]`)
    if (label) {
      return label.textContent?.trim() || ''
    }
  }
  
  // Strategy 2: Parent label
  const parentLabel = element.closest('label')
  if (parentLabel) {
    return parentLabel.textContent?.trim() || ''
  }
  
  // Strategy 3: aria-label
  const ariaLabel = element.getAttribute('aria-label')
  if (ariaLabel) {
    return ariaLabel.trim()
  }
  
  // Strategy 4: aria-labelledby
  const labelledBy = element.getAttribute('aria-labelledby')
  if (labelledBy) {
    const labelElement = document.getElementById(labelledBy)
    if (labelElement) {
      return labelElement.textContent?.trim() || ''
    }
  }
  
  // Strategy 5: ATS-specific selectors
  if (atsType === 'workday') {
    // Workday often has labels as previous siblings
    const prevSibling = element.previousElementSibling
    if (prevSibling?.tagName === 'LABEL') {
      return prevSibling.textContent?.trim() || ''
    }
  }
  
  // Strategy 6: Placeholder as fallback
  return element.placeholder || 'Untitled Field'
}

/**
 * Detect if field should use essay mode (STAR outline)
 */
function detectEssayMode(
  label: string,
  maxLength: number,
  config: DetectionConfig
): boolean {
  const labelLower = label.toLowerCase()
  
  // Check for essay keywords
  for (const keyword of config.essayKeywords) {
    if (labelLower.includes(keyword)) {
      return true
    }
  }
  
  // Check character limit
  if (maxLength >= config.minCharLimit) {
    return true
  }
  
  return false
}

/**
 * Watch for dynamically added fields
 */
export function watchForQuestionFields(
  callback: (fields: QuestionField[]) => void,
  atsType: ATSType | null
): MutationObserver {
  const observer = new MutationObserver(() => {
    const fields = detectQuestionFields(atsType)
    if (fields.length > 0) {
      callback(fields)
    }
  })
  
  // Observe form containers only
  const forms = document.querySelectorAll('form')
  forms.forEach(form => {
    observer.observe(form, {
      childList: true,
      subtree: true
    })
  })
  
  return observer
}
```

**Verification:**
- TypeScript compiles without errors
- Detection logic handles multiple label strategies
- Essay mode detection works correctly

---

### Task 2: Create Suggest Button Component
**File:** `src/components/SuggestAnswerButton.tsx`
**Action:** Button that triggers AI generation

```typescript
import React, { useState } from 'react'
import type { AIProvider } from '@/types/ai'

interface SuggestAnswerButtonProps {
  onSuggest: () => void
  isLoading: boolean
  isEssay: boolean
  activeProvider: AIProvider
}

export function SuggestAnswerButton({
  onSuggest,
  isLoading,
  isEssay,
  activeProvider
}: SuggestAnswerButtonProps) {
  const providerBadge = {
    mock: { text: 'Mock AI', color: 'bg-gray-500' },
    openai: { text: 'GPT-4o', color: 'bg-green-600' },
    anthropic: { text: 'Claude', color: 'bg-purple-600' }
  }[activeProvider]
  
  return (
    <button
      onClick={onSuggest}
      disabled={isLoading}
      className="inline-flex items-center gap-2 px-3 py-1.5 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed shadow-sm transition-colors"
      title={isEssay ? 'Generate STAR outline' : 'Generate answer suggestions'}
    >
      {isLoading ? (
        <>
          <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
              fill="none"
            />
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            />
          </svg>
          Generating...
        </>
      ) : (
        <>
          <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
            />
          </svg>
          {isEssay ? 'Suggest Outline' : 'Suggest Answer'}
        </>
      )}
      
      {/* Provider badge */}
      <span className={`text-xs px-1.5 py-0.5 rounded ${providerBadge.color}`}>
        {providerBadge.text}
      </span>
    </button>
  )
}
```

**Verification:**
- Component renders correctly
- Provider badge displays active provider
- Loading state shows spinner
- Essay mode shows different text

---

### Task 3: Create Draft Selector Component
**File:** `src/components/DraftSelector.tsx`
**Action:** UI for cycling through 3 drafts

```typescript
import React, { useState } from 'react'
import type { GenerateResult } from '@/types/ai'

interface DraftSelectorProps {
  result: GenerateResult
  onInsert: (draft: string) => void
  onRegenerate: () => void
  onClose: () => void
}

export function DraftSelector({
  result,
  onInsert,
  onRegenerate,
  onClose
}: DraftSelectorProps) {
  const [currentIndex, setCurrentIndex] = useState(0)
  
  const currentDraft = result.drafts[currentIndex]
  const currentTone = result.tones[currentIndex]
  
  const handlePrevious = () => {
    setCurrentIndex((prev) => (prev === 0 ? 2 : prev - 1))
  }
  
  const handleNext = () => {
    setCurrentIndex((prev) => (prev === 2 ? 0 : prev + 1))
  }
  
  const handleInsert = () => {
    onInsert(currentDraft)
  }
  
  // Highlight placeholders in draft
  const highlightedDraft = highlightPlaceholders(currentDraft)
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10000] p-4">
      <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              {result.metadata.essayMode ? 'STAR Outline' : 'Suggested Answer'}
            </h3>
            <p className="text-sm text-gray-500 mt-1">
              {result.metadata.essayMode 
                ? 'Use this outline to structure your answer' 
                : 'Review and customize before inserting'}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
            title="Close"
          >
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Draft content */}
        <div className="flex-1 overflow-y-auto p-4">
          <div className="bg-gray-50 rounded-lg p-4 mb-4">
            <div className="flex items-center justify-between mb-3">
              <span className="text-xs font-medium text-gray-500 uppercase">
                Tone: {currentTone}
              </span>
              <span className="text-xs text-gray-400">
                Draft {currentIndex + 1} of 3
              </span>
            </div>
            
            <div 
              className="text-gray-800 whitespace-pre-wrap leading-relaxed"
              dangerouslySetInnerHTML={{ __html: highlightedDraft }}
            />
          </div>
          
          {/* Provider info */}
          <div className="flex items-start gap-2 text-xs text-gray-500 bg-blue-50 border border-blue-200 rounded p-3">
            <svg className="h-4 w-4 text-blue-600 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
            </svg>
            <div>
              <p className="font-medium text-blue-900 mb-1">
                {result.provider === 'mock' ? '⚠️ Mock AI Mode' : `✓ Powered by ${result.provider === 'openai' ? 'OpenAI GPT-4o' : 'Anthropic Claude'}`}
              </p>
              <p>
                {result.provider === 'mock' 
                  ? 'Template-based suggestions. Add your API key in settings for AI-generated answers.'
                  : 'Replace all [placeholders] with your specific details before submitting.'}
              </p>
            </div>
          </div>
        </div>
        
        {/* Navigation and actions */}
        <div className="border-t p-4 space-y-3">
          {/* Draft navigation */}
          <div className="flex items-center justify-between">
            <button
              onClick={handlePrevious}
              className="flex items-center gap-1 px-3 py-1.5 text-sm text-gray-700 bg-gray-100 rounded hover:bg-gray-200 transition-colors"
            >
              <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
              </svg>
              Previous
            </button>
            
            <span className="text-sm text-gray-500">
              {currentIndex + 1} / 3
            </span>
            
            <button
              onClick={handleNext}
              className="flex items-center gap-1 px-3 py-1.5 text-sm text-gray-700 bg-gray-100 rounded hover:bg-gray-200 transition-colors"
            >
              Next
              <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
              </svg>
            </button>
          </div>
          
          {/* Action buttons */}
          <div className="flex gap-2">
            <button
              onClick={onRegenerate}
              className="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
            >
              Regenerate New Drafts
            </button>
            <button
              onClick={handleInsert}
              className="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 transition-colors"
            >
              Insert This Draft
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

/**
 * Highlight placeholders in square brackets
 */
function highlightPlaceholders(text: string): string {
  return text.replace(
    /\[([^\]]+)\]/g,
    '<span class="bg-yellow-100 text-yellow-900 font-medium px-1 rounded">[<span class="underline">$1</span>]</span>'
  )
}
```

**Verification:**
- Component renders modal correctly
- Draft cycling works (Previous/Next)
- Placeholders highlighted visually
- Provider badge displays correctly
- Insert and Regenerate buttons functional

---

### Task 4: Create Content Script Integration
**File:** `src/entrypoints/content/ai-suggest.content.ts`
**Action:** Content script that injects suggest buttons

```typescript
import { defineContentScript } from 'wxt/sandbox'
import { detectQuestionFields, watchForQuestionFields } from '@/lib/ai/question-detector'
import type { QuestionField } from '@/lib/ai/question-detector'
import type { ATSType } from '@/types/ats'

export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_idle',
  
  async main() {
    // Wait for ATS detection
    const atsType = await getDetectedATS()
    if (!atsType) {
      console.log('[AI Suggest] No ATS detected, skipping question detection')
      return
    }
    
    console.log('[AI Suggest] Initializing question detection for', atsType)
    
    // Initial detection
    const initialFields = detectQuestionFields(atsType)
    injectSuggestButtons(initialFields, atsType)
    
    // Watch for dynamically added fields
    watchForQuestionFields((fields) => {
      injectSuggestButtons(fields, atsType)
    }, atsType)
  }
})

/**
 * Get detected ATS from storage (set by ats-detector content script)
 */
async function getDetectedATS(): Promise<ATSType | null> {
  return new Promise((resolve) => {
    chrome.storage.local.get(['detected_ats'], (result) => {
      resolve(result.detected_ats || null)
    })
  })
}

/**
 * Inject suggest buttons for detected question fields
 */
function injectSuggestButtons(fields: QuestionField[], atsType: ATSType) {
  for (const field of fields) {
    // Skip if button already injected
    if (field.element.dataset.aiSuggestInjected === 'true') {
      continue
    }
    
    // Mark as injected
    field.element.dataset.aiSuggestInjected = 'true'
    field.element.dataset.aiIsEssay = String(field.isEssay)
    
    // Create button container
    const container = createButtonContainer(field, atsType)
    
    // Insert button next to field
    insertButton(field.element, container, atsType)
  }
}

/**
 * Create button container element
 */
function createButtonContainer(field: QuestionField, atsType: ATSType): HTMLElement {
  const container = document.createElement('div')
  container.className = 'ai-suggest-button-container'
  container.style.cssText = `
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
  `
  
  // Add confidence indicator (debug only - remove in production)
  if (process.env.NODE_ENV === 'development') {
    const confidence = document.createElement('span')
    confidence.textContent = `Confidence: ${Math.round(field.confidence * 100)}%`
    confidence.style.cssText = 'font-size: 11px; color: #666;'
    container.appendChild(confidence)
  }
  
  // Button will be rendered by React
  const buttonRoot = document.createElement('div')
  buttonRoot.id = `ai-suggest-button-${generateId()}`
  buttonRoot.dataset.fieldLabel = field.label
  buttonRoot.dataset.isEssay = String(field.isEssay)
  container.appendChild(buttonRoot)
  
  return container
}

/**
 * Insert button in appropriate location based on ATS
 */
function insertButton(
  field: HTMLTextAreaElement | HTMLInputElement,
  container: HTMLElement,
  atsType: ATSType
) {
  // Strategy 1: After the field
  if (field.parentElement) {
    field.parentElement.insertBefore(container, field.nextSibling)
    return
  }
  
  // Fallback: Append to parent
  field.parentNode?.appendChild(container)
}

/**
 * Generate unique ID for button
 */
function generateId(): string {
  return Math.random().toString(36).substring(2, 11)
}
```

**Verification:**
- Content script loads on ATS pages
- Question fields detected correctly
- Buttons injected in appropriate locations
- No duplicate buttons created

---

### Task 5: Create React Integration for Buttons
**File:** `src/entrypoints/content/ai-suggest.content/index.tsx`
**Action:** React app for suggest buttons

```typescript
import React, { useState, useEffect } from 'react'
import ReactDOM from 'react-dom/client'
import { SuggestAnswerButton } from '@/components/SuggestAnswerButton'
import { DraftSelector } from '@/components/DraftSelector'
import { getAIProvider, getActiveProvider } from '@/lib/ai'
import type { GenerateResult, AIProvider } from '@/types/ai'
import type { Profile } from '@/types/profile'

interface AIButtonAppProps {
  fieldElement: HTMLTextAreaElement | HTMLInputElement
  fieldLabel: string
  isEssay: boolean
}

function AIButtonApp({ fieldElement, fieldLabel, isEssay }: AIButtonAppProps) {
  const [isLoading, setIsLoading] = useState(false)
  const [result, setResult] = useState<GenerateResult | null>(null)
  const [activeProvider, setActiveProvider] = useState<AIProvider>('mock')
  const [profile, setProfile] = useState<Profile | null>(null)
  
  // Load active provider and profile
  useEffect(() => {
    Promise.all([
      getActiveProvider(),
      chrome.storage.local.get(['profile'])
    ]).then(([provider, storage]) => {
      setActiveProvider(provider)
      setProfile(storage.profile || null)
    })
  }, [])
  
  const handleSuggest = async () => {
    if (!profile) {
      alert('Please set up your profile first in the extension settings.')
      return
    }
    
    setIsLoading(true)
    
    try {
      const provider = await getAIProvider()
      const generateResult = await provider.generateAnswer({
        question: fieldLabel,
        questionContext: fieldElement.placeholder,
        userProfile: profile,
        tone: 'professional', // Default tone, user can regenerate with different tone
        essayMode: isEssay,
        role: profile.rolePreference || 'other'
      })
      
      setResult(generateResult)
    } catch (error) {
      console.error('Failed to generate answer:', error)
      alert(`Failed to generate answer: ${error.message}`)
    } finally {
      setIsLoading(false)
    }
  }
  
  const handleInsert = (draft: string) => {
    fieldElement.value = draft
    fieldElement.dispatchEvent(new Event('input', { bubbles: true }))
    fieldElement.dispatchEvent(new Event('change', { bubbles: true }))
    setResult(null)
  }
  
  const handleRegenerate = () => {
    setResult(null)
    handleSuggest()
  }
  
  const handleClose = () => {
    setResult(null)
  }
  
  return (
    <>
      <SuggestAnswerButton
        onSuggest={handleSuggest}
        isLoading={isLoading}
        isEssay={isEssay}
        activeProvider={activeProvider}
      />
      
      {result && (
        <DraftSelector
          result={result}
          onInsert={handleInsert}
          onRegenerate={handleRegenerate}
          onClose={handleClose}
        />
      )}
    </>
  )
}

// Mount React app for each button
export function mountAISuggestButton(
  rootElement: HTMLElement,
  fieldElement: HTMLTextAreaElement | HTMLInputElement,
  fieldLabel: string,
  isEssay: boolean
) {
  const root = ReactDOM.createRoot(rootElement)
  root.render(
    <AIButtonApp
      fieldElement={fieldElement}
      fieldLabel={fieldLabel}
      isEssay={isEssay}
    />
  )
}
```

**Verification:**
- React app mounts correctly
- Button triggers generation
- Draft selector shows results
- Insert updates field value
- Regenerate creates new drafts

---

### Task 6: Update Content Script to Mount React
**File:** `src/entrypoints/content/ai-suggest.content.ts`
**Action:** Call React mount function

```typescript
import { defineContentScript } from 'wxt/sandbox'
import { detectQuestionFields, watchForQuestionFields } from '@/lib/ai/question-detector'
import { mountAISuggestButton } from './ai-suggest.content/index'
import type { QuestionField } from '@/lib/ai/question-detector'
import type { ATSType } from '@/types/ats'

export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_idle',
  
  async main() {
    // Wait for ATS detection
    const atsType = await getDetectedATS()
    if (!atsType) {
      console.log('[AI Suggest] No ATS detected, skipping question detection')
      return
    }
    
    console.log('[AI Suggest] Initializing question detection for', atsType)
    
    // Initial detection
    const initialFields = detectQuestionFields(atsType)
    injectSuggestButtons(initialFields, atsType)
    
    // Watch for dynamically added fields
    watchForQuestionFields((fields) => {
      injectSuggestButtons(fields, atsType)
    }, atsType)
  }
})

async function getDetectedATS(): Promise<ATSType | null> {
  return new Promise((resolve) => {
    chrome.storage.local.get(['detected_ats'], (result) => {
      resolve(result.detected_ats || null)
    })
  })
}

function injectSuggestButtons(fields: QuestionField[], atsType: ATSType) {
  for (const field of fields) {
    if (field.element.dataset.aiSuggestInjected === 'true') {
      continue
    }
    
    field.element.dataset.aiSuggestInjected = 'true'
    
    const container = createButtonContainer(field, atsType)
    insertButton(field.element, container, atsType)
    
    // Mount React app
    const buttonRoot = container.querySelector('[id^="ai-suggest-button-"]') as HTMLElement
    if (buttonRoot) {
      mountAISuggestButton(buttonRoot, field.element, field.label, field.isEssay)
    }
  }
}

function createButtonContainer(field: QuestionField, atsType: ATSType): HTMLElement {
  const container = document.createElement('div')
  container.className = 'ai-suggest-button-container'
  container.style.cssText = `
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
  `
  
  const buttonRoot = document.createElement('div')
  buttonRoot.id = `ai-suggest-button-${generateId()}`
  container.appendChild(buttonRoot)
  
  return container
}

function insertButton(
  field: HTMLTextAreaElement | HTMLInputElement,
  container: HTMLElement,
  atsType: ATSType
) {
  if (field.parentElement) {
    field.parentElement.insertBefore(container, field.nextSibling)
    return
  }
  
  field.parentNode?.appendChild(container)
}

function generateId(): string {
  return Math.random().toString(36).substring(2, 11)
}
```

---

### Task 7: Create Question Detection Tests
**File:** `src/lib/ai/question-detector.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { detectQuestionFields, detectEssayMode } from './question-detector'

describe('Question Detector', () => {
  beforeEach(() => {
    document.body.innerHTML = ''
  })
  
  describe('detectQuestionFields', () => {
    it('should detect textarea with question label', () => {
      document.body.innerHTML = `
        <label for="q1">Why do you want this role?</label>
        <textarea id="q1"></textarea>
      `
      
      const fields = detectQuestionFields(null)
      
      expect(fields).toHaveLength(1)
      expect(fields[0].label).toContain('Why')
      expect(fields[0].confidence).toBeGreaterThan(0.7)
    })
    
    it('should detect essay mode for long char limits', () => {
      document.body.innerHTML = `
        <label for="q1">Describe a challenge</label>
        <textarea id="q1" maxlength="1000"></textarea>
      `
      
      const fields = detectQuestionFields(null)
      
      expect(fields[0].isEssay).toBe(true)
    })
    
    it('should not detect non-question fields', () => {
      document.body.innerHTML = `
        <label for="name">Full Name</label>
        <input type="text" id="name" />
      `
      
      const fields = detectQuestionFields(null)
      
      expect(fields).toHaveLength(0)
    })
  })
})
```

---

## Dependencies

- Plans 03-01, 03-02, 03-03 complete (AI providers ready)
- Phase 2 complete (ATS detection available)
- React and Tailwind CSS configured

---

## Success Criteria

- [ ] Question detection identifies appropriate fields
- [ ] Essay mode triggered for fields ≥500 char limit
- [ ] "Suggest Answer" button appears on detected fields
- [ ] Button shows active provider badge
- [ ] Clicking button generates 3 drafts
- [ ] Draft selector modal displays with cycling
- [ ] Placeholders highlighted visually
- [ ] Insert button fills field with selected draft
- [ ] Regenerate button creates new drafts
- [ ] Provider indication clear (Mock vs Real AI)
- [ ] No duplicate buttons on same field
- [ ] All tests pass

---

## Non-Goals (Deferred)

- Settings UI for API keys (Plan 03-05)
- Tone selection in UI (v2 feature)
- Draft editing before insertion (v2 feature)

---

## Rollback Plan

If critical issues:
1. Revert commit
2. Keep Plans 03-01, 03-02, 03-03
3. Remove question detection and UI components

---

**End of Plan 03-04**
