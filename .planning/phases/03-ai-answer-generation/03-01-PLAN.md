# Plan 03-01: AI Provider Infrastructure

**Phase:** 3 - AI Answer Generation
**Wave:** 1
**Priority:** P0 (Must-Have)
**Estimated Duration:** 30 minutes

---

## Goal

Build the foundational provider abstraction layer for AI answer generation. Create type-safe interfaces, configuration management, and storage utilities that all AI providers (mock, OpenAI, Anthropic) will implement. This establishes the architecture that enables provider-agnostic generation and seamless switching between mock/real AI.

---

## Context

From CONTEXT.md:
- Support both OpenAI + Claude (user chooses provider)
- API key validation with retry (test with real API call before saving)
- Settings page section for AI configuration

From RESEARCH.md:
- Provider abstraction is critical — never directly couple to specific AI SDK
- Use official SDKs (openai, @anthropic-ai/sdk)
- Chrome Storage API for keys (plain storage in v1, encryption deferred to v2 per STATE.md)
- Three tone variants: Professional, Concise, Story-Driven
- Essay mode for questions ≥500 chars (STAR outline)

---

## Requirements Covered

- REQ-AI-01: Mock AI response system (infrastructure)
- REQ-AI-02: User-provided API key support (storage)
- REQ-AI-03: Role-specific AI tuning (types)
- REQ-AI-04: Placeholder markers (types)
- REQ-AI-05: Essay question handling (types)

---

## Tasks

### Task 1: Create AI Type Definitions
**File:** `src/types/ai.ts`
**Action:** Create comprehensive type system for AI providers

```typescript
export type AIProvider = 'mock' | 'openai' | 'anthropic'

export type ToneVariant = 'professional' | 'concise' | 'story-driven'

export type RoleType = 'tech' | 'healthcare' | 'finance' | 'marketing' | 'operations' | 'other'

export type GenerateParams = {
  question: string
  questionContext?: string // Label text, surrounding content
  userProfile: Profile
  tone: ToneVariant
  essayMode: boolean // True when char limit ≥500
  role: RoleType
}

export type GenerateResult = {
  drafts: [string, string, string] // Exactly 3 drafts
  provider: AIProvider
  tones: [ToneVariant, ToneVariant, ToneVariant]
  metadata: {
    essayMode: boolean
    generatedAt: number
    question: string
  }
}

export type AIConfig = {
  provider: AIProvider
  openaiKey?: string
  anthropicKey?: string
  openaiValidatedAt?: number
  anthropicValidatedAt?: number
  lastUsedProvider?: AIProvider
}

export interface IAIProvider {
  readonly name: AIProvider
  generateAnswer(params: GenerateParams): Promise<GenerateResult>
  validateKey?(apiKey: string): Promise<boolean>
  supportsStreaming: boolean
}

export type ValidationResult = {
  valid: boolean
  error?: string
  provider: AIProvider
}
```

**Verification:**
- TypeScript compiles without errors
- Types exported from `src/types/index.ts`

---

### Task 2: Create AI Configuration Store
**File:** `src/lib/ai/config.ts`
**Action:** Build Chrome Storage wrapper for AI configuration

```typescript
import type { AIConfig, AIProvider, ValidationResult } from '@/types/ai'

const STORAGE_KEY = 'ai_config'

const DEFAULT_CONFIG: AIConfig = {
  provider: 'mock',
  lastUsedProvider: 'mock'
}

export async function getAIConfig(): Promise<AIConfig> {
  const result = await chrome.storage.local.get([STORAGE_KEY])
  return result[STORAGE_KEY] || DEFAULT_CONFIG
}

export async function setAIProvider(provider: AIProvider): Promise<void> {
  const config = await getAIConfig()
  config.provider = provider
  config.lastUsedProvider = provider
  await chrome.storage.local.set({ [STORAGE_KEY]: config })
}

export async function saveAPIKey(
  provider: 'openai' | 'anthropic',
  apiKey: string,
  validatedAt: number
): Promise<void> {
  const config = await getAIConfig()
  
  if (provider === 'openai') {
    config.openaiKey = apiKey
    config.openaiValidatedAt = validatedAt
  } else {
    config.anthropicKey = apiKey
    config.anthropicValidatedAt = validatedAt
  }
  
  await chrome.storage.local.set({ [STORAGE_KEY]: config })
}

export async function getAPIKey(
  provider: 'openai' | 'anthropic'
): Promise<string | null> {
  const config = await getAIConfig()
  return provider === 'openai' ? config.openaiKey || null : config.anthropicKey || null
}

export async function clearAPIKey(provider: 'openai' | 'anthropic'): Promise<void> {
  const config = await getAIConfig()
  
  if (provider === 'openai') {
    delete config.openaiKey
    delete config.openaiValidatedAt
    // Switch to mock if this was the active provider
    if (config.provider === 'openai') {
      config.provider = 'mock'
    }
  } else {
    delete config.anthropicKey
    delete config.anthropicValidatedAt
    if (config.provider === 'anthropic') {
      config.provider = 'mock'
    }
  }
  
  await chrome.storage.local.set({ [STORAGE_KEY]: config })
}

export async function hasValidKey(provider: 'openai' | 'anthropic'): Promise<boolean> {
  const config = await getAIConfig()
  
  if (provider === 'openai') {
    return !!(config.openaiKey && config.openaiValidatedAt)
  } else {
    return !!(config.anthropicKey && config.anthropicValidatedAt)
  }
}

export async function getActiveProvider(): Promise<AIProvider> {
  const config = await getAIConfig()
  return config.provider
}
```

**Verification:**
- Functions compile without errors
- Chrome Storage API types resolved correctly

---

### Task 3: Create Base Provider Interface
**File:** `src/lib/ai/providers/base.ts`
**Action:** Define abstract provider class

```typescript
import type { IAIProvider, GenerateParams, GenerateResult, AIProvider } from '@/types/ai'

export abstract class BaseAIProvider implements IAIProvider {
  abstract readonly name: AIProvider
  abstract readonly supportsStreaming: boolean
  
  abstract generateAnswer(params: GenerateParams): Promise<GenerateResult>
  
  // Optional for mock provider
  async validateKey?(apiKey: string): Promise<boolean>
  
  /**
   * Helper: Build role-specific context for system prompt
   */
  protected getRoleContext(role: string): string {
    const contexts = {
      tech: 'You are assisting a software engineer. Use technical vocabulary naturally.',
      healthcare: 'You are assisting a healthcare professional. Use medical terminology appropriately.',
      finance: 'You are assisting a finance professional. Use financial terminology naturally.',
      marketing: 'You are assisting a marketing professional. Use marketing and campaign terminology.',
      operations: 'You are assisting an operations professional. Use logistics and process terminology.',
      other: 'You are assisting a professional job seeker.'
    }
    
    return contexts[role] || contexts.other
  }
  
  /**
   * Helper: Build tone-specific instructions
   */
  protected getToneInstructions(tone: string): string {
    const instructions = {
      professional: 'Use neutral, polished language. Be diplomatic and error-free without being overly formal.',
      concise: 'Use minimal but complete language. Provide the shortest possible answer that fully addresses the question.',
      'story-driven': 'Use narrative style with compelling storytelling elements. Create engaging flow with specific examples.'
    }
    
    return instructions[tone] || instructions.professional
  }
  
  /**
   * Helper: Validate draft has required placeholders
   */
  protected validateDraft(draft: string): boolean {
    // Ensure draft has at least one placeholder
    const placeholderPattern = /\[.*?\]/
    return placeholderPattern.test(draft)
  }
}
```

**Verification:**
- Abstract class compiles
- Helper methods accessible to subclasses

---

### Task 4: Create Provider Factory
**File:** `src/lib/ai/factory.ts`
**Action:** Factory pattern for provider instantiation

```typescript
import type { IAIProvider, AIProvider } from '@/types/ai'
import { getAIConfig, getAPIKey } from './config'

// Import providers (will be implemented in later plans)
// import { MockProvider } from './providers/mock'
// import { OpenAIProvider } from './providers/openai'
// import { AnthropicProvider } from './providers/anthropic'

/**
 * Get the appropriate AI provider based on current configuration
 */
export async function getAIProvider(): Promise<IAIProvider> {
  const config = await getAIConfig()
  
  switch (config.provider) {
    case 'openai': {
      const apiKey = await getAPIKey('openai')
      if (!apiKey) {
        // Fall back to mock if no key
        console.warn('OpenAI provider selected but no API key found. Falling back to mock.')
        // return new MockProvider()
        throw new Error('OpenAI provider not yet implemented')
      }
      // return new OpenAIProvider(apiKey)
      throw new Error('OpenAI provider not yet implemented')
    }
    
    case 'anthropic': {
      const apiKey = await getAPIKey('anthropic')
      if (!apiKey) {
        console.warn('Anthropic provider selected but no API key found. Falling back to mock.')
        // return new MockProvider()
        throw new Error('Anthropic provider not yet implemented')
      }
      // return new AnthropicProvider(apiKey)
      throw new Error('Anthropic provider not yet implemented')
    }
    
    case 'mock':
    default:
      // return new MockProvider()
      throw new Error('Mock provider not yet implemented')
  }
}

/**
 * Create provider instance for validation (doesn't save to config)
 */
export async function createProviderForValidation(
  provider: 'openai' | 'anthropic',
  apiKey: string
): Promise<IAIProvider> {
  switch (provider) {
    case 'openai':
      // return new OpenAIProvider(apiKey)
      throw new Error('OpenAI provider not yet implemented')
    
    case 'anthropic':
      // return new AnthropicProvider(apiKey)
      throw new Error('Anthropic provider not yet implemented')
    
    default:
      throw new Error(`Unknown provider: ${provider}`)
  }
}
```

**Verification:**
- Factory functions compile
- Error handling for missing implementations

---

### Task 5: Create Public AI API
**File:** `src/lib/ai/index.ts`
**Action:** Export clean public interface

```typescript
// Types
export type {
  AIProvider,
  ToneVariant,
  RoleType,
  GenerateParams,
  GenerateResult,
  AIConfig,
  IAIProvider,
  ValidationResult
} from '@/types/ai'

// Configuration
export {
  getAIConfig,
  setAIProvider,
  saveAPIKey,
  getAPIKey,
  clearAPIKey,
  hasValidKey,
  getActiveProvider
} from './config'

// Factory
export {
  getAIProvider,
  createProviderForValidation
} from './factory'

// Base (for extending)
export { BaseAIProvider } from './providers/base'
```

**Verification:**
- All exports resolve correctly
- No circular dependencies

---

### Task 6: Install AI SDKs
**Action:** Add OpenAI and Anthropic packages

```bash
pnpm add openai @anthropic-ai/sdk
```

**Verification:**
- Packages installed successfully
- `package.json` updated
- `pnpm-lock.yaml` updated

---

### Task 7: Update Type Index
**File:** `src/types/index.ts`
**Action:** Export AI types from central location

```typescript
// Existing exports...
export * from './profile'
export * from './ats'

// Add AI types
export * from './ai'
```

**Verification:**
- Types importable via `@/types`

---

## Testing Strategy

### Unit Tests

**File:** `src/lib/ai/config.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import {
  getAIConfig,
  setAIProvider,
  saveAPIKey,
  getAPIKey,
  clearAPIKey,
  hasValidKey,
  getActiveProvider
} from './config'

// Mock Chrome Storage API
vi.mock('chrome', () => ({
  storage: {
    local: {
      get: vi.fn(),
      set: vi.fn()
    }
  }
}), { virtual: true })

describe('AI Configuration', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })
  
  describe('getAIConfig', () => {
    it('should return default config when no config exists', async () => {
      chrome.storage.local.get.mockResolvedValue({})
      
      const config = await getAIConfig()
      
      expect(config.provider).toBe('mock')
      expect(config.lastUsedProvider).toBe('mock')
    })
    
    it('should return stored config when exists', async () => {
      const storedConfig = {
        provider: 'openai',
        openaiKey: 'test-key',
        openaiValidatedAt: Date.now()
      }
      chrome.storage.local.get.mockResolvedValue({ ai_config: storedConfig })
      
      const config = await getAIConfig()
      
      expect(config.provider).toBe('openai')
      expect(config.openaiKey).toBe('test-key')
    })
  })
  
  describe('setAIProvider', () => {
    it('should update provider and lastUsedProvider', async () => {
      chrome.storage.local.get.mockResolvedValue({
        ai_config: { provider: 'mock' }
      })
      
      await setAIProvider('openai')
      
      expect(chrome.storage.local.set).toHaveBeenCalledWith({
        ai_config: expect.objectContaining({
          provider: 'openai',
          lastUsedProvider: 'openai'
        })
      })
    })
  })
  
  describe('saveAPIKey', () => {
    it('should save OpenAI key with validation timestamp', async () => {
      chrome.storage.local.get.mockResolvedValue({ ai_config: {} })
      const validatedAt = Date.now()
      
      await saveAPIKey('openai', 'sk-test-key', validatedAt)
      
      expect(chrome.storage.local.set).toHaveBeenCalledWith({
        ai_config: expect.objectContaining({
          openaiKey: 'sk-test-key',
          openaiValidatedAt: validatedAt
        })
      })
    })
    
    it('should save Anthropic key with validation timestamp', async () => {
      chrome.storage.local.get.mockResolvedValue({ ai_config: {} })
      const validatedAt = Date.now()
      
      await saveAPIKey('anthropic', 'sk-ant-test-key', validatedAt)
      
      expect(chrome.storage.local.set).toHaveBeenCalledWith({
        ai_config: expect.objectContaining({
          anthropicKey: 'sk-ant-test-key',
          anthropicValidatedAt: validatedAt
        })
      })
    })
  })
  
  describe('clearAPIKey', () => {
    it('should clear OpenAI key and switch to mock if active', async () => {
      chrome.storage.local.get.mockResolvedValue({
        ai_config: {
          provider: 'openai',
          openaiKey: 'test-key',
          openaiValidatedAt: Date.now()
        }
      })
      
      await clearAPIKey('openai')
      
      expect(chrome.storage.local.set).toHaveBeenCalledWith({
        ai_config: expect.objectContaining({
          provider: 'mock'
        })
      })
      expect(chrome.storage.local.set).toHaveBeenCalledWith({
        ai_config: expect.not.objectContaining({
          openaiKey: expect.anything()
        })
      })
    })
  })
  
  describe('hasValidKey', () => {
    it('should return true when key and validation exist', async () => {
      chrome.storage.local.get.mockResolvedValue({
        ai_config: {
          openaiKey: 'test-key',
          openaiValidatedAt: Date.now()
        }
      })
      
      const result = await hasValidKey('openai')
      
      expect(result).toBe(true)
    })
    
    it('should return false when key missing', async () => {
      chrome.storage.local.get.mockResolvedValue({ ai_config: {} })
      
      const result = await hasValidKey('openai')
      
      expect(result).toBe(false)
    })
  })
})
```

---

## Dependencies

- Phase 1 complete (Profile types available)
- TypeScript strict mode configured
- Vitest testing infrastructure

---

## Success Criteria

- [ ] All TypeScript files compile without errors
- [ ] `pnpm type-check` passes
- [ ] All unit tests pass (`pnpm test src/lib/ai/config.test.ts`)
- [ ] AI types exported from `@/types`
- [ ] Configuration functions work with Chrome Storage API
- [ ] OpenAI and Anthropic SDKs installed
- [ ] Factory pattern ready for provider implementations
- [ ] Base provider abstract class ready for extension

---

## Non-Goals (Deferred to Later Plans)

- Actual provider implementations (Plans 03-02, 03-03)
- Question detection logic (Plan 03-04)
- UI components (Plans 03-04, 03-05)
- Prompt building logic (Plan 03-02)

---

## Rollback Plan

If critical issues found:
1. Revert commit for this plan
2. Remove `src/lib/ai/` directory
3. Remove `src/types/ai.ts`
4. Uninstall AI SDKs: `pnpm remove openai @anthropic-ai/sdk`

---

**End of Plan 03-01**
