---
phase: 03-ai-answer-generation
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/storage/encryption.ts
  - src/lib/ai/config.ts
  - src/lib/storage/encryption.test.ts
  - src/lib/ai/config.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "API keys stored encrypted in chrome.storage.local using AES-256"
    - "Encryption happens automatically on API key save"
    - "Decryption happens automatically on API key retrieval"
    - "Encryption/decryption is transparent to existing code"
  artifacts:
    - path: "src/lib/storage/encryption.ts"
      provides: "Web Crypto API wrapper for AES-256-GCM encryption/decryption"
      exports: ["encryptData", "decryptData"]
      min_lines: 80
    - path: "src/lib/ai/config.ts"
      provides: "Encrypted API key storage"
      contains: "await encryptData"
      modified: true
    - path: "src/lib/storage/encryption.test.ts"
      provides: "Encryption round-trip tests"
      contains: "encryptData.*decryptData"
  key_links:
    - from: "src/lib/ai/config.ts"
      to: "src/lib/storage/encryption.ts"
      via: "encryptData/decryptData imports"
      pattern: "import.*encryptData.*decryptData"
    - from: "saveAPIKey()"
      to: "encryptData()"
      via: "encrypt before chrome.storage.local.set"
      pattern: "encryptData\\(apiKey\\)"
    - from: "getAPIKey()"
      to: "decryptData()"
      via: "decrypt after chrome.storage.local.get"
      pattern: "decryptData\\(.*Key\\)"
---

<objective>
Add Web Crypto API encryption layer for API keys to satisfy REQ-AI-02 requirement and close VERIFICATION.md Gap 1 (blocker).

Purpose: Secure API keys in chrome.storage.local using AES-256-GCM encryption. Currently, OpenAI and Anthropic API keys are stored in plain text, violating ROADMAP.md Definition of Done requirement "API key stored encrypted".

Output: Encryption wrapper + updated config.ts with transparent encryption/decryption
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-answer-generation/03-VERIFICATION.md
@src/lib/ai/config.ts
@src/types/ai.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Web Crypto API encryption wrapper</name>
  <files>src/lib/storage/encryption.ts</files>
  <action>
Create encryption utility using Web Crypto API (AES-256-GCM):

**Functions to implement:**

1. `encryptData(plaintext: string): Promise<string>`
   - Generate random IV (12 bytes for GCM)
   - Derive encryption key from static salt (stored in code, not secret - real security comes from Chrome extension sandboxing)
   - Use AES-256-GCM for authenticated encryption
   - Encode result as base64 string: `${base64(iv)}:${base64(ciphertext)}`
   - Return base64-encoded IV:ciphertext pair

2. `decryptData(encrypted: string): Promise<string>`
   - Split encrypted string into IV and ciphertext parts
   - Decode from base64
   - Derive same encryption key from static salt
   - Decrypt using AES-256-GCM
   - Return original plaintext string
   - Throw EncryptionError if decryption fails (wrong format, corrupted data)

3. `deriveKey(): Promise<CryptoKey>`
   - Use PBKDF2 to derive key from static passphrase (extensions are isolated by Chrome)
   - Salt: random bytes generated once, stored as constant
   - Iterations: 100,000 (OWASP recommendation)
   - Hash: SHA-256
   - Key length: 256 bits
   - Return CryptoKey for AES-GCM

**Why this approach:**
- Chrome extensions are sandboxed per-extension (no cross-extension access)
- Static salt/passphrase is acceptable because threat model is local device compromise
- Real security benefit: prevents accidental key exposure in logs, exports, debugging
- AES-256-GCM provides authenticated encryption (detects tampering)

**Error handling:**
- Create custom EncryptionError class extending Error
- Catch Web Crypto API errors and wrap with clear messages
- Handle malformed input (missing colon separator, invalid base64)

**Implementation notes:**
- Use TextEncoder/TextDecoder for string ‚Üî ArrayBuffer conversion
- Use window.crypto.subtle (available in Chrome extension context)
- Export types: EncryptionError class
  </action>
  <verify>pnpm type-check passes, no ESLint warnings</verify>
  <done>encryption.ts exports encryptData, decryptData, EncryptionError with full Web Crypto API implementation</done>
</task>

<task type="auto">
  <name>Task 2: Add encryption to config.ts API key storage</name>
  <files>src/lib/ai/config.ts</files>
  <action>
Update config.ts to encrypt API keys before storage and decrypt on retrieval:

**Changes to saveAPIKey()** (lines 43-59):
```typescript
import { encryptData } from '@/lib/storage/encryption';

export async function saveAPIKey(
  provider: 'openai' | 'anthropic',
  apiKey: string,
  validatedAt: number
): Promise<void> {
  const config = await getAIConfig();
  
  // Encrypt API key before storing
  const encryptedKey = await encryptData(apiKey);

  if (provider === 'openai') {
    config.openaiKey = encryptedKey;  // Store encrypted version
    config.openaiValidatedAt = validatedAt;
  } else {
    config.anthropicKey = encryptedKey;  // Store encrypted version
    config.anthropicValidatedAt = validatedAt;
  }

  await chrome.storage.local.set({ [STORAGE_KEY]: config });
}
```

**Changes to getAPIKey()** (lines 88-91):
```typescript
import { decryptData } from '@/lib/storage/encryption';

export async function getAPIKey(provider: 'openai' | 'anthropic'): Promise<string | null> {
  const config = await getAIConfig();
  const encryptedKey = provider === 'openai' ? config.openaiKey : config.anthropicKey;
  
  if (!encryptedKey) return null;
  
  try {
    // Decrypt API key from storage
    return await decryptData(encryptedKey);
  } catch (error) {
    // If decryption fails (corrupted data, old format), treat as no key
    console.error(`Failed to decrypt ${provider} API key:`, error);
    return null;
  }
}
```

**Migration consideration:**
- Existing plain-text keys will fail decryption (no colon separator)
- getAPIKey() returns null for corrupted/old keys
- User must re-enter API key (acceptable for v1 - no data loss, just re-validation)
- Add comment noting migration behavior

**Update getAIProvider()** (lines 118-151):
- No changes needed - already uses getAPIKey() which now handles decryption
- Verify fallback to MockProvider still works when decryption fails

**Type updates:**
- Update JSDoc comments to note keys are stored encrypted
- Update AIConfig type comments in src/types/ai.ts if needed
  </action>
  <verify>pnpm type-check passes, pnpm lint passes, no console errors</verify>
  <done>saveAPIKey encrypts before storing, getAPIKey decrypts after reading, existing code using getAPIKey continues to work</done>
</task>

<task type="auto">
  <name>Task 3: Create encryption unit tests</name>
  <files>src/lib/storage/encryption.test.ts</files>
  <action>
Create comprehensive tests for encryption wrapper:

**Test suites:**

1. **encryptData tests:**
   - Should encrypt string and return base64-encoded result
   - Should return different ciphertext for same input (random IV)
   - Should include colon separator between IV and ciphertext
   - Should handle empty string
   - Should handle unicode characters (emoji, Chinese, special chars)

2. **decryptData tests:**
   - Should decrypt encrypted data back to original plaintext
   - Should throw EncryptionError for invalid format (no colon)
   - Should throw EncryptionError for corrupted ciphertext
   - Should throw EncryptionError for wrong IV

3. **Round-trip tests:**
   - Encrypt then decrypt should return original string
   - Should work for API key formats (sk-..., sk-ant-...)
   - Should work for long strings (500+ chars)

4. **deriveKey tests:**
   - Should return CryptoKey with AES-GCM algorithm
   - Should return same key on multiple calls (deterministic)

**Use Vitest:** import { describe, it, expect } from 'vitest'

**Test data examples:**
- OpenAI key: "sk-proj-abc123def456..."
- Anthropic key: "sk-ant-api03-xyz789..."
- Unicode: "Hello ‰∏ñÁïå üîê"
  </action>
  <verify>pnpm test src/lib/storage/encryption.test.ts passes all tests</verify>
  <done>Encryption tests cover all functions with edge cases, all tests passing</done>
</task>

<task type="auto">
  <name>Task 4: Update config.ts tests for encryption</name>
  <files>src/lib/ai/config.test.ts</files>
  <action>
Update existing config.ts tests to account for encrypted storage:

**Changes needed:**

1. **saveAPIKey() tests** (lines referencing plain storage):
   - Update assertions to expect encrypted values in storage (base64 format with colon)
   - Add test: "should store API key in encrypted format"
   - Verify stored key is NOT plain text: `expect(stored.openaiKey).not.toBe(originalKey)`
   - Verify stored key matches encryption format: `expect(stored.openaiKey).toMatch(/^[A-Za-z0-9+/]+=*:[A-Za-z0-9+/]+=*$/)`

2. **getAPIKey() tests**:
   - Mock encrypted key in storage before retrieval
   - Verify decrypted result matches original plain key
   - Add test: "should return null for corrupted encrypted data"
   - Add test: "should handle decryption failure gracefully"

3. **Round-trip tests**:
   - Add test: "saveAPIKey then getAPIKey should return original key"
   - Use real encryption (not mocked) to verify full flow

4. **Migration scenario**:
   - Add test: "getAPIKey returns null for old plain-text keys (migration)"
   - Manually set plain key in storage, verify getAPIKey returns null

**Note:** Some tests may need async/await updates due to encryption being async.
  </action>
  <verify>pnpm test src/lib/ai/config.test.ts passes all tests</verify>
  <done>Config tests updated to verify encrypted storage, all tests passing including migration scenario</done>
</task>

</tasks>

<verification>
Run verification checks:

1. **Encryption verification:**
   ```bash
   pnpm test src/lib/storage/encryption.test.ts
   ```
   All tests should pass.

2. **Config integration verification:**
   ```bash
   pnpm test src/lib/ai/config.test.ts
   ```
   All tests should pass with encryption active.

3. **Type safety:**
   ```bash
   pnpm type-check
   ```
   No TypeScript errors.

4. **Manual verification (optional):**
   - Open Chrome DevTools ‚Üí Application ‚Üí Storage ‚Üí Local Storage
   - Save an API key via AISettings component
   - Verify stored value is encrypted (base64:base64 format, NOT plain "sk-...")
   - Retrieve key via UI, verify it works correctly (decryption successful)

5. **Gap closure verification:**
   - VERIFICATION.md Gap 1 truth: "API keys stored encrypted locally" ‚úì
   - REQ-AI-02: "User-provided API key support (encrypted storage)" ‚úì
   - ROADMAP.md DoD: "API key stored encrypted" ‚úì
</verification>

<success_criteria>
- [ ] src/lib/storage/encryption.ts created with encryptData/decryptData using AES-256-GCM
- [ ] src/lib/ai/config.ts updated to encrypt on save, decrypt on read
- [ ] Encryption tests pass (round-trip, error handling, unicode)
- [ ] Config tests pass with encrypted storage
- [ ] API keys stored in base64:base64 format (not plain text)
- [ ] Existing code using getAPIKey() continues to work (transparent decryption)
- [ ] VERIFICATION.md Gap 1 closed (blocker removed)
- [ ] REQ-AI-02 satisfied (encrypted API key storage)
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-answer-generation/03-06-SUMMARY.md`
</output>
