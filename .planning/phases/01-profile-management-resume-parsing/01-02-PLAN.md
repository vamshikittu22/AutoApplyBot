---
phase: 01-profile-management-resume-parsing
plan: 02
type: execute
wave: 2
depends_on: ['01-01']
files_modified:
  - src/lib/parser/resume-parser.ts
  - src/lib/parser/section-detector.ts
  - src/lib/parser/field-extractor.ts
  - tests/unit/parser/resume-parser.test.ts
autonomous: true

must_haves:
  truths:
    - "User pastes resume text and sees structured parsed output"
    - "At least 75% of key fields (name, email, phone, work, education, skills) are extracted correctly"
    - "Low-confidence fields are flagged for manual review"
  artifacts:
    - path: "src/lib/parser/resume-parser.ts"
      provides: "Main resume parsing orchestration with ≥75% accuracy"
      exports: ["parseResume"]
      min_lines: 100
    - path: "src/lib/parser/section-detector.ts"
      provides: "Resume section identification (contact, experience, education, skills)"
      exports: ["detectSections"]
    - path: "src/lib/parser/field-extractor.ts"
      provides: "Field extraction with confidence scoring"
      exports: ["extractContact", "extractWorkHistory", "extractEducation", "extractSkills"]
    - path: "tests/unit/parser/resume-parser.test.ts"
      provides: "Parser accuracy validation (≥75% on key fields)"
  key_links:
    - from: "src/lib/parser/resume-parser.ts"
      to: "@/types/resume"
      via: "Returns ParsedResume type"
      pattern: "ParsedResume"
    - from: "src/lib/parser/field-extractor.ts"
      to: "@/types/resume"
      via: "Uses FieldConfidence for scoring"
      pattern: "FieldConfidence"
---

<objective>
Build plain text resume parser achieving ≥75% accuracy on key fields.

**Purpose:** Extract structured profile data from pasted resume text using pattern matching and heuristics. Supports chronological resume format with confidence scoring per field (REQ-PRO-01).

**Output:** Fully functional resume parser with unit tests proving ≥75% accuracy on name, email, phone, work history, education, and skills.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-profile-management-resume-parsing/01-01-SUMMARY.md
@TECHSTACK.md
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Section Detector</name>
  <files>src/lib/parser/section-detector.ts</files>
  <action>
Create `src/lib/parser/section-detector.ts` to identify resume sections using keyword matching:

**Implementation approach:**
- Split resume text into lines
- Identify section headers using common patterns (case-insensitive):
  - Contact: "contact", email pattern, phone pattern at top of resume
  - Experience: "experience", "work history", "employment", "professional experience"
  - Education: "education", "academic", "degrees"
  - Skills: "skills", "technical skills", "competencies", "technologies"
  - Projects: "projects", "portfolio"
  - Certifications: "certifications", "licenses", "credentials"
- Group lines between headers into sections
- Handle resumes without explicit headers (heuristic: contact at top, experience after, education near bottom)

```typescript
import { ResumeSection } from '@/types/resume'

export interface DetectedSection {
  type: ResumeSection
  startLine: number
  endLine: number
  content: string
  confidence: number // 0-100
}

/**
 * Detects resume sections using keyword matching and structural heuristics.
 * Handles both explicit headers and implicit structure.
 */
export function detectSections(resumeText: string): DetectedSection[] {
  // Implementation:
  // 1. Normalize text (trim, lowercase for matching)
  // 2. Find section headers using keyword patterns
  // 3. If no headers found, use heuristic structure detection
  // 4. Return sections with confidence scores
  
  const lines = resumeText.split('\n')
  const sections: DetectedSection[] = []
  
  // Header patterns
  const patterns = {
    contact: /^(contact|personal|information)/i,
    experience: /^(experience|work|employment|professional)/i,
    education: /^(education|academic|degrees)/i,
    skills: /^(skills|technical|competencies|technologies)/i,
    projects: /^(projects|portfolio)/i,
    certifications: /^(certifications?|licenses?|credentials)/i
  }
  
  // Section detection logic...
  
  return sections
}

/**
 * Fallback heuristic when no clear headers exist.
 * Assumes: contact info at top, experience in middle, education/skills at bottom.
 */
function detectImplicitStructure(lines: string[]): DetectedSection[] {
  // Heuristic rules...
}
```

**Confidence scoring:**
- Explicit header match: 90-100%
- Keyword density match: 70-89%
- Heuristic position: 50-69%

Add comprehensive JSDoc and handle edge cases (no headers, ambiguous sections).
  </action>
  <verify>
Run `pnpm type-check` - must pass.
Test manually with 2-3 sample resumes (with and without headers) - verify sections detected.
  </verify>
  <done>
Section detector exported with detectSections function. Handles explicit headers and implicit structure with confidence scoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Field Extractors</name>
  <files>src/lib/parser/field-extractor.ts</files>
  <action>
Create `src/lib/parser/field-extractor.ts` with specialized extractors for each field type:

```typescript
import type { PersonalInfo, WorkExperience, Education, Skill, FieldConfidence } from '@/types/profile'
import type { FieldConfidence as ConfidenceScore } from '@/types/resume'

/**
 * Extract contact information from resume section.
 * Targets: name, email, phone, location
 */
export function extractContact(text: string): {
  contact: Partial<PersonalInfo>
  confidence: ConfidenceScore[]
} {
  const contact: Partial<PersonalInfo> = {}
  const confidence: ConfidenceScore[] = []
  
  // Email extraction (high confidence if regex match)
  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/
  const emailMatch = text.match(emailRegex)
  if (emailMatch) {
    contact.email = emailMatch[0]
    confidence.push({ field: 'email', confidence: 95, source: 'exact-match' })
  }
  
  // Phone extraction
  const phoneRegex = /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/
  const phoneMatch = text.match(phoneRegex)
  if (phoneMatch) {
    contact.phone = phoneMatch[0].replace(/[-.\s]/g, '')
    confidence.push({ field: 'phone', confidence: 90, source: 'pattern-match' })
  }
  
  // Name extraction (first line heuristic or lines before email)
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean)
  if (lines.length > 0) {
    // Name is typically first non-empty line
    contact.name = lines[0]
    confidence.push({ field: 'name', confidence: 80, source: 'heuristic', rawValue: lines[0] })
  }
  
  // Location extraction (look for City, State pattern)
  const locationRegex = /([A-Z][a-z]+(?:\s[A-Z][a-z]+)*),?\s+([A-Z]{2}|[A-Z][a-z]+)/
  const locationMatch = text.match(locationRegex)
  if (locationMatch) {
    contact.location = locationMatch[0]
    confidence.push({ field: 'location', confidence: 75, source: 'pattern-match' })
  }
  
  return { contact, confidence }
}

/**
 * Extract work experience entries from resume section.
 * Targets: position, company, dates, achievements
 */
export function extractWorkHistory(text: string): {
  workHistory: WorkExperience[]
  confidence: ConfidenceScore[]
} {
  const workHistory: WorkExperience[] = []
  const confidence: ConfidenceScore[] = []
  
  // Split by job entries (typically separated by blank lines or date patterns)
  const entries = splitByJobEntries(text)
  
  entries.forEach((entry, index) => {
    const work: Partial<WorkExperience> = { id: crypto.randomUUID() }
    
    // Extract position (first line or bold text)
    const lines = entry.split('\n').filter(Boolean)
    if (lines.length > 0) {
      work.position = lines[0]
      confidence.push({ field: `workHistory[${index}].position`, confidence: 85, source: 'heuristic' })
    }
    
    // Extract company (second line or after position)
    if (lines.length > 1) {
      work.company = lines[1]
      confidence.push({ field: `workHistory[${index}].company`, confidence: 80, source: 'heuristic' })
    }
    
    // Extract dates (look for YYYY-YYYY or Month YYYY pattern)
    const dateRegex = /(\w+\s+)?\d{4}\s*[-–—]\s*((\w+\s+)?\d{4}|Present|Current)/i
    const dateMatch = entry.match(dateRegex)
    if (dateMatch) {
      work.startDate = dateMatch[1] || dateMatch[0].split(/[-–—]/)[0].trim()
      work.endDate = dateMatch[2] || 'Present'
      confidence.push({ field: `workHistory[${index}].dates`, confidence: 90, source: 'pattern-match' })
    }
    
    // Extract achievements (bullet points: lines starting with -, •, *, or numbers)
    const bulletRegex = /^[\s]*[-•*\d.]+\s+(.+)$/gm
    const bullets = [...entry.matchAll(bulletRegex)].map(m => m[1].trim())
    if (bullets.length > 0) {
      work.achievements = bullets
      confidence.push({ field: `workHistory[${index}].achievements`, confidence: 85, source: 'pattern-match' })
    }
    
    if (work.position && work.company) {
      workHistory.push(work as WorkExperience)
    }
  })
  
  return { workHistory, confidence }
}

/**
 * Split experience section into individual job entries
 */
function splitByJobEntries(text: string): string[] {
  // Implementation: split by double newlines or date patterns
  return text.split(/\n\s*\n/).filter(Boolean)
}

/**
 * Extract education entries from resume section.
 * Targets: degree, institution, dates
 */
export function extractEducation(text: string): {
  education: Education[]
  confidence: ConfidenceScore[]
} {
  const education: Education[] = []
  const confidence: ConfidenceScore[] = []
  
  // Similar structure to extractWorkHistory
  const entries = text.split(/\n\s*\n/).filter(Boolean)
  
  entries.forEach((entry, index) => {
    const edu: Partial<Education> = { id: crypto.randomUUID() }
    const lines = entry.split('\n').filter(Boolean)
    
    // Degree (first line)
    if (lines.length > 0) {
      edu.degree = lines[0]
      confidence.push({ field: `education[${index}].degree`, confidence: 85, source: 'heuristic' })
    }
    
    // Institution (second line)
    if (lines.length > 1) {
      edu.institution = lines[1]
      confidence.push({ field: `education[${index}].institution`, confidence: 85, source: 'heuristic' })
    }
    
    // Dates
    const dateRegex = /(\d{4})\s*[-–—]\s*(\d{4}|Present)/
    const dateMatch = entry.match(dateRegex)
    if (dateMatch) {
      edu.startDate = dateMatch[1]
      edu.endDate = dateMatch[2]
      confidence.push({ field: `education[${index}].dates`, confidence: 90, source: 'pattern-match' })
    }
    
    if (edu.degree && edu.institution) {
      education.push(edu as Education)
    }
  })
  
  return { education, confidence }
}

/**
 * Extract skills from resume section.
 * Targets: skill names (comma-separated or bulleted)
 */
export function extractSkills(text: string): {
  skills: Skill[]
  confidence: ConfidenceScore[]
} {
  const skills: Skill[] = []
  const confidence: ConfidenceScore[] = []
  
  // Remove section header
  const cleanedText = text.replace(/^skills:?/i, '').trim()
  
  // Split by commas, bullets, or newlines
  const skillNames = cleanedText
    .split(/[,•\n]/)
    .map(s => s.trim().replace(/^[-*\d.]+\s*/, ''))
    .filter(s => s.length > 1 && s.length < 50) // Filter noise
  
  skillNames.forEach(name => {
    skills.push({ name, category: undefined })
  })
  
  if (skills.length > 0) {
    confidence.push({ 
      field: 'skills', 
      confidence: skills.length >= 3 ? 85 : 65, 
      source: 'pattern-match' 
    })
  }
  
  return { skills, confidence }
}
```

Add JSDoc comments explaining extraction logic and confidence thresholds. Handle edge cases (missing data, malformed dates).
  </action>
  <verify>
Run `pnpm type-check` - must pass.
Test manually with sample resume sections - verify extraction works.
  </verify>
  <done>
Field extractors exported: extractContact, extractWorkHistory, extractEducation, extractSkills. Each returns data + confidence scores.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Main Resume Parser</name>
  <files>src/lib/parser/resume-parser.ts</files>
  <action>
Create `src/lib/parser/resume-parser.ts` as main parsing orchestrator:

```typescript
import type { ParsedResume, ParserResult } from '@/types/resume'
import type { Profile } from '@/types/profile'
import { detectSections } from './section-detector'
import { extractContact, extractWorkHistory, extractEducation, extractSkills } from './field-extractor'
import { EMPTY_PROFILE, KEY_PARSE_FIELDS } from '@/constants/profile-schema'

/**
 * Parse plain text resume into structured profile data.
 * 
 * Achieves ≥75% accuracy on key fields (REQ-PRO-01):
 * - name, email, phone (contact info)
 * - work history entries
 * - education entries  
 * - skills list
 * 
 * @param resumeText - Plain text resume (paste input)
 * @returns ParsedResume with profile data and confidence scores
 */
export function parseResume(resumeText: string): ParserResult<ParsedResume> {
  try {
    if (!resumeText || resumeText.trim().length < 50) {
      return {
        success: false,
        error: 'Resume text too short (minimum 50 characters)',
        partialData: undefined
      }
    }
    
    // Step 1: Detect sections
    const sections = detectSections(resumeText)
    
    // Step 2: Extract fields from each section
    const profile: Partial<Profile> = { ...EMPTY_PROFILE }
    const allConfidenceScores = []
    const parseErrors = []
    const unparsedText: string[] = []
    
    sections.forEach(section => {
      try {
        switch (section.type) {
          case 'contact': {
            const { contact, confidence } = extractContact(section.content)
            profile.personal = { ...profile.personal, ...contact }
            allConfidenceScores.push(...confidence)
            break
          }
          case 'experience': {
            const { workHistory, confidence } = extractWorkHistory(section.content)
            profile.workHistory = workHistory
            allConfidenceScores.push(...confidence)
            break
          }
          case 'education': {
            const { education, confidence } = extractEducation(section.content)
            profile.education = education
            allConfidenceScores.push(...confidence)
            break
          }
          case 'skills': {
            const { skills, confidence } = extractSkills(section.content)
            profile.skills = skills
            allConfidenceScores.push(...confidence)
            break
          }
          case 'unknown': {
            unparsedText.push(section.content)
            break
          }
        }
      } catch (error) {
        parseErrors.push({
          section: section.type,
          message: error instanceof Error ? error.message : 'Unknown error',
          severity: 'warning'
        })
      }
    })
    
    // Step 3: Calculate overall accuracy
    const accuracy = calculateParseAccuracy(profile, allConfidenceScores)
    
    if (accuracy < 50) {
      return {
        success: false,
        error: `Parse accuracy too low (${accuracy}%). Resume format may not be supported.`,
        partialData: { profile, confidenceScores: allConfidenceScores, parseErrors, unparsedText }
      }
    }
    
    return {
      success: true,
      data: {
        profile,
        confidenceScores: allConfidenceScores,
        parseErrors,
        unparsedText
      }
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown parsing error'
    }
  }
}

/**
 * Calculate overall parse accuracy based on key fields (REQ-PRO-01).
 * Returns percentage (0-100).
 */
function calculateParseAccuracy(
  profile: Partial<Profile>,
  confidenceScores: any[]
): number {
  const keyFieldsExtracted = [
    !!profile.personal?.name,
    !!profile.personal?.email,
    !!profile.personal?.phone,
    (profile.workHistory?.length || 0) > 0,
    (profile.education?.length || 0) > 0,
    (profile.skills?.length || 0) >= 3
  ]
  
  const extractedCount = keyFieldsExtracted.filter(Boolean).length
  const totalKeyFields = keyFieldsExtracted.length
  
  return Math.round((extractedCount / totalKeyFields) * 100)
}
```

Add comprehensive JSDoc explaining REQ-PRO-01 acceptance criteria and error handling.
  </action>
  <verify>
Run `pnpm type-check` - must pass.
Test manually with full sample resume - verify ParsedResume returned with ≥75% accuracy.
  </verify>
  <done>
Main parser exported with parseResume function. Returns ParsedResume with profile data, confidence scores, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Parser Unit Tests</name>
  <files>tests/unit/parser/resume-parser.test.ts</files>
  <action>
Create `tests/unit/parser/resume-parser.test.ts` with comprehensive test coverage:

```typescript
import { describe, it, expect } from 'vitest'
import { parseResume } from '@/lib/parser/resume-parser'

describe('parseResume', () => {
  describe('success cases', () => {
    it('should parse complete chronological resume with ≥75% accuracy', () => {
      const sampleResume = `
John Doe
john.doe@email.com | (555) 123-4567 | San Francisco, CA

EXPERIENCE
Senior Software Engineer
Tech Company Inc.
January 2020 - Present
- Led development of microservices architecture serving 1M+ users
- Reduced API latency by 40% through optimization
- Mentored 5 junior engineers

Software Engineer
Startup Co.
June 2018 - December 2019
- Built React-based dashboard used by 10K+ customers
- Implemented CI/CD pipeline reducing deploy time by 60%

EDUCATION
Bachelor of Science in Computer Science
University of California
September 2014 - May 2018

SKILLS
JavaScript, TypeScript, React, Node.js, Python, AWS, Docker, PostgreSQL
      `
      
      const result = parseResume(sampleResume)
      
      expect(result.success).toBe(true)
      if (result.success) {
        const { profile, confidenceScores } = result.data
        
        // Verify key fields extracted (REQ-PRO-01)
        expect(profile.personal?.name).toBe('John Doe')
        expect(profile.personal?.email).toBe('john.doe@email.com')
        expect(profile.personal?.phone).toContain('555')
        expect(profile.workHistory).toHaveLength(2)
        expect(profile.education).toHaveLength(1)
        expect(profile.skills!.length).toBeGreaterThanOrEqual(3)
        
        // Verify ≥75% accuracy requirement
        const accuracy = calculateTestAccuracy(profile)
        expect(accuracy).toBeGreaterThanOrEqual(75)
        
        // Verify confidence scores present
        expect(confidenceScores.length).toBeGreaterThan(0)
      }
    })
    
    it('should handle resume without explicit section headers', () => {
      const implicitResume = `
Jane Smith
jane@example.com
(555) 987-6543

Product Manager at Big Corp
2021 - Present
• Launched 3 products generating $2M ARR

MBA, Business Administration
Harvard Business School, 2020

Skills: Product Strategy, SQL, Tableau
      `
      
      const result = parseResume(implicitResume)
      
      expect(result.success).toBe(true)
      if (result.success) {
        expect(result.data.profile.personal?.name).toBeTruthy()
        expect(result.data.profile.personal?.email).toBeTruthy()
      }
    })
  })
  
  describe('error cases', () => {
    it('should reject too-short text', () => {
      const result = parseResume('John Doe')
      expect(result.success).toBe(false)
      expect(result.error).toContain('too short')
    })
    
    it('should return partial data on low accuracy', () => {
      const lowQualityResume = `
Random text that doesn't look like a resume at all.
Just some nonsense content here.
      `
      
      const result = parseResume(lowQualityResume)
      
      if (!result.success && result.partialData) {
        expect(result.partialData.profile).toBeDefined()
      }
    })
  })
  
  describe('confidence scoring', () => {
    it('should mark email as high confidence (≥90%)', () => {
      const result = parseResume('John Doe\njohn@example.com\n\nSenior Engineer\nCompany\n2020-Present')
      
      if (result.success) {
        const emailScore = result.data.confidenceScores.find(s => s.field === 'email')
        expect(emailScore?.confidence).toBeGreaterThanOrEqual(90)
      }
    })
    
    it('should flag low-confidence fields (<70%)', () => {
      const ambiguousResume = 'Name\nSome text\nMore text'
      const result = parseResume(ambiguousResume)
      
      if (result.success) {
        const lowConfFields = result.data.confidenceScores.filter(s => s.confidence < 70)
        expect(lowConfFields.length).toBeGreaterThan(0)
      }
    })
  })
})

/**
 * Calculate test accuracy helper
 */
function calculateTestAccuracy(profile: any): number {
  const checks = [
    !!profile.personal?.name,
    !!profile.personal?.email,
    !!profile.personal?.phone,
    (profile.workHistory?.length || 0) > 0,
    (profile.education?.length || 0) > 0,
    (profile.skills?.length || 0) >= 3
  ]
  return Math.round((checks.filter(Boolean).length / checks.length) * 100)
}
```

Add more test cases for edge cases: special characters, international formats, missing sections.
  </action>
  <verify>
Run `pnpm test` - all tests must pass.
Verify test coverage includes ≥75% accuracy validation per REQ-PRO-01.
  </verify>
  <done>
Parser tests passing with ≥75% accuracy validation. Coverage includes success cases, error cases, and confidence scoring verification.
  </done>
</task>

</tasks>

<verification>
**Parser Functionality:**
- [ ] `parseResume()` extracts name, email, phone, work history, education, skills
- [ ] Parser achieves ≥75% accuracy on key fields (verified by tests)
- [ ] Confidence scores generated for all extracted fields
- [ ] Low-confidence fields flagged (<70%)
- [ ] Error handling for malformed input

**Code Quality:**
- [ ] `pnpm type-check` passes
- [ ] `pnpm test` passes with all parser tests
- [ ] No external dependencies added (vanilla JS + regex per TECHSTACK.md)

**Requirements Coverage:**
- [ ] REQ-PRO-01: Paste resume extraction with ≥75% accuracy implemented and tested
</verification>

<success_criteria>
- Resume parser fully functional with section detection and field extraction
- ≥75% accuracy achieved on key fields (name, email, phone, work, education, skills)
- Confidence scoring implemented for all fields
- Parser handles resumes with and without explicit section headers
- Unit tests validate accuracy requirement
- All TypeScript types from Plan 01 correctly used
- Zero external parsing libraries added (pure TypeScript implementation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-profile-management-resume-parsing/01-02-SUMMARY.md` following the standard summary template.
</output>
