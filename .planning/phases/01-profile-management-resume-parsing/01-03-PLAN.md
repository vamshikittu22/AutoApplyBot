---
phase: 01-profile-management-resume-parsing
plan: 03
type: execute
wave: 2
depends_on: ['01-01']
files_modified:
  - src/lib/storage/encryption.ts
  - src/lib/storage/profile-storage.ts
  - tests/unit/storage/encryption.test.ts
  - tests/unit/storage/profile-storage.test.ts
autonomous: true

must_haves:
  truths:
    - "Profile data is stored encrypted using Web Crypto API (AES-GCM)"
    - "Encrypted profile persists across browser restarts"
    - "No plaintext profile data visible in Chrome Storage inspection"
  artifacts:
    - path: "src/lib/storage/encryption.ts"
      provides: "Web Crypto API wrapper for AES-GCM encryption/decryption"
      exports: ["encryptData", "decryptData", "generateKey"]
      min_lines: 80
    - path: "src/lib/storage/profile-storage.ts"
      provides: "Chrome Storage API wrapper with automatic encryption"
      exports: ["saveProfile", "loadProfile", "deleteProfile", "exportData"]
    - path: "tests/unit/storage/encryption.test.ts"
      provides: "Encryption/decryption validation tests"
    - path: "tests/unit/storage/profile-storage.test.ts"
      provides: "Profile storage integration tests"
  key_links:
    - from: "src/lib/storage/profile-storage.ts"
      to: "src/lib/storage/encryption.ts"
      via: "Encrypts profile before storage"
      pattern: "encryptData.*profile"
    - from: "src/lib/storage/profile-storage.ts"
      to: "@/types/profile"
      via: "Saves Profile type"
      pattern: "Profile"
---

<objective>
Implement encrypted local storage using Web Crypto API and Chrome Storage.

**Purpose:** Store user profile data encrypted in Chrome local storage with AES-GCM encryption (REQ-PRO-05). Enable data export and delete functionality (REQ-PRO-06).

**Output:** Fully functional encrypted storage layer with unit tests proving encryption works correctly.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-profile-management-resume-parsing/01-01-SUMMARY.md
@TECHSTACK.md
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Web Crypto Encryption Module</name>
  <files>src/lib/storage/encryption.ts</files>
  <action>
Create `src/lib/storage/encryption.ts` with AES-GCM encryption using Web Crypto API:

**Implementation requirements:**
- Use Web Crypto API (native, zero dependencies per TECHSTACK.md)
- AES-GCM 256-bit encryption
- Generate encryption key using PBKDF2 from device-specific seed
- Include initialization vector (IV) with each encrypted payload
- Return base64-encoded encrypted data for storage compatibility

```typescript
/**
 * Web Crypto API wrapper for AES-GCM encryption.
 * 
 * Used for encrypting profile data before storage in Chrome local storage (REQ-PRO-05).
 * Zero dependencies - uses native browser Web Crypto API.
 */

const ALGORITHM = 'AES-GCM'
const KEY_LENGTH = 256
const IV_LENGTH = 12 // 96 bits recommended for GCM
const SALT_LENGTH = 16

/**
 * Generate encryption key from device-specific seed using PBKDF2.
 * Key is derived from a combination of fixed salt and device-specific data.
 * 
 * In v1, we use a simple approach: key stored in chrome.storage.local (non-encrypted area).
 * v2+ may add user password protection.
 */
export async function generateKey(): Promise<CryptoKey> {
  // Get or create device seed
  const seed = await getOrCreateDeviceSeed()
  
  const encoder = new TextEncoder()
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    encoder.encode(seed),
    'PBKDF2',
    false,
    ['deriveKey']
  )
  
  const salt = await getSalt()
  
  return crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: ALGORITHM, length: KEY_LENGTH },
    true, // extractable (for key management)
    ['encrypt', 'decrypt']
  )
}

/**
 * Get or create persistent device seed (stored in chrome.storage.local).
 * This seed is used to derive the encryption key.
 */
async function getOrCreateDeviceSeed(): Promise<string> {
  const SEED_KEY = '_device_seed'
  
  // Try to get existing seed
  const result = await chrome.storage.local.get(SEED_KEY)
  
  if (result[SEED_KEY]) {
    return result[SEED_KEY]
  }
  
  // Generate new seed
  const randomBytes = crypto.getRandomValues(new Uint8Array(32))
  const seed = Array.from(randomBytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
  
  await chrome.storage.local.set({ [SEED_KEY]: seed })
  return seed
}

/**
 * Get salt for PBKDF2 (static for this device)
 */
async function getSalt(): Promise<Uint8Array> {
  const SALT_KEY = '_encryption_salt'
  
  const result = await chrome.storage.local.get(SALT_KEY)
  
  if (result[SALT_KEY]) {
    return Uint8Array.from(atob(result[SALT_KEY]), c => c.charCodeAt(0))
  }
  
  const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH))
  const saltBase64 = btoa(String.fromCharCode(...salt))
  await chrome.storage.local.set({ [SALT_KEY]: saltBase64 })
  
  return salt
}

/**
 * Encrypt data using AES-GCM.
 * 
 * @param data - Plain text data to encrypt
 * @param key - Encryption key (generated via generateKey)
 * @returns Base64-encoded encrypted payload (includes IV)
 */
export async function encryptData(data: string, key: CryptoKey): Promise<string> {
  const encoder = new TextEncoder()
  const dataBuffer = encoder.encode(data)
  
  // Generate random IV for this encryption
  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH))
  
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: ALGORITHM, iv: iv },
    key,
    dataBuffer
  )
  
  // Combine IV + encrypted data for storage
  const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength)
  combined.set(iv, 0)
  combined.set(new Uint8Array(encryptedBuffer), iv.length)
  
  // Convert to base64 for storage compatibility
  return btoa(String.fromCharCode(...combined))
}

/**
 * Decrypt data using AES-GCM.
 * 
 * @param encryptedData - Base64-encoded encrypted payload (includes IV)
 * @param key - Decryption key (same as encryption key)
 * @returns Decrypted plain text
 */
export async function decryptData(encryptedData: string, key: CryptoKey): Promise<string> {
  // Decode base64
  const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0))
  
  // Extract IV and encrypted data
  const iv = combined.slice(0, IV_LENGTH)
  const data = combined.slice(IV_LENGTH)
  
  const decryptedBuffer = await crypto.subtle.decrypt(
    { name: ALGORITHM, iv: iv },
    key,
    data
  )
  
  const decoder = new TextDecoder()
  return decoder.decode(decryptedBuffer)
}

/**
 * Encrypt object (converts to JSON first)
 */
export async function encryptObject<T>(obj: T, key: CryptoKey): Promise<string> {
  const json = JSON.stringify(obj)
  return encryptData(json, key)
}

/**
 * Decrypt object (parses JSON after decryption)
 */
export async function decryptObject<T>(encryptedData: string, key: CryptoKey): Promise<T> {
  const json = await decryptData(encryptedData, key)
  return JSON.parse(json)
}
```

Add comprehensive JSDoc explaining encryption approach and security considerations per REQ-PRO-05.
  </action>
  <verify>
Run `pnpm type-check` - must pass.
Test manually: encrypt a string, verify output is not plaintext, decrypt and verify matches original.
  </verify>
  <done>
Encryption module exported with generateKey, encryptData, decryptData, encryptObject, decryptObject. Uses Web Crypto API AES-GCM per REQ-PRO-05.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Profile Storage Module</name>
  <files>src/lib/storage/profile-storage.ts</files>
  <action>
Create `src/lib/storage/profile-storage.ts` with Chrome Storage wrapper and automatic encryption:

```typescript
import type { Profile } from '@/types/profile'
import { generateKey, encryptObject, decryptObject } from './encryption'

const STORAGE_KEY = 'encrypted_profile'
const APPLICATIONS_KEY = 'applications'
const SETTINGS_KEY = 'settings'

/**
 * Save profile to encrypted Chrome local storage (REQ-PRO-05).
 * 
 * @param profile - User profile to save
 * @throws Error if encryption or storage fails
 */
export async function saveProfile(profile: Profile): Promise<void> {
  try {
    const key = await generateKey()
    const encryptedProfile = await encryptObject(profile, key)
    
    await chrome.storage.local.set({ [STORAGE_KEY]: encryptedProfile })
  } catch (error) {
    throw new Error(`Failed to save profile: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Load profile from encrypted Chrome local storage.
 * 
 * @returns Profile if exists, null if not found
 * @throws Error if decryption fails
 */
export async function loadProfile(): Promise<Profile | null> {
  try {
    const result = await chrome.storage.local.get(STORAGE_KEY)
    
    if (!result[STORAGE_KEY]) {
      return null
    }
    
    const key = await generateKey()
    const profile = await decryptObject<Profile>(result[STORAGE_KEY], key)
    
    return profile
  } catch (error) {
    throw new Error(`Failed to load profile: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Delete all user data from Chrome storage (REQ-PRO-06).
 * Includes profile, applications, settings, encryption keys.
 * 
 * ‚ö†Ô∏è This action is irreversible.
 */
export async function deleteProfile(): Promise<void> {
  try {
    await chrome.storage.local.clear()
  } catch (error) {
    throw new Error(`Failed to delete profile: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Export all user data as JSON (REQ-PRO-06).
 * Includes profile, applications, settings (decrypted for portability).
 * 
 * @returns JSON object with all user data
 */
export async function exportData(): Promise<{
  profile: Profile | null
  applications: any[]
  settings: any
  exportedAt: string
}> {
  try {
    const profile = await loadProfile()
    
    // Load applications and settings (not encrypted in v1)
    const result = await chrome.storage.local.get([APPLICATIONS_KEY, SETTINGS_KEY])
    
    return {
      profile,
      applications: result[APPLICATIONS_KEY] || [],
      settings: result[SETTINGS_KEY] || {},
      exportedAt: new Date().toISOString()
    }
  } catch (error) {
    throw new Error(`Failed to export data: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Check if profile exists in storage.
 * Used for onboarding flow detection.
 */
export async function hasProfile(): Promise<boolean> {
  const result = await chrome.storage.local.get(STORAGE_KEY)
  return !!result[STORAGE_KEY]
}

/**
 * Update specific profile fields without loading entire profile.
 * Useful for quick updates (e.g., changing role preference).
 */
export async function updateProfile(updates: Partial<Profile>): Promise<void> {
  const profile = await loadProfile()
  
  if (!profile) {
    throw new Error('No profile exists to update')
  }
  
  const updatedProfile: Profile = {
    ...profile,
    ...updates,
    updatedAt: new Date().toISOString()
  }
  
  await saveProfile(updatedProfile)
}
```

Add JSDoc comments explaining REQ-PRO-05 (encryption) and REQ-PRO-06 (export/delete).
  </action>
  <verify>
Run `pnpm type-check` - must pass.
Test manually: save a profile, inspect Chrome Storage (should see encrypted blob), load profile (should match original).
  </verify>
  <done>
Profile storage module exported with saveProfile, loadProfile, deleteProfile, exportData, hasProfile, updateProfile. Automatic encryption per REQ-PRO-05.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Storage Unit Tests</name>
  <files>tests/unit/storage/encryption.test.ts, tests/unit/storage/profile-storage.test.ts</files>
  <action>
Create comprehensive unit tests for encryption and profile storage:

**File: tests/unit/storage/encryption.test.ts**
```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { generateKey, encryptData, decryptData, encryptObject, decryptObject } from '@/lib/storage/encryption'

describe('encryption', () => {
  let encryptionKey: CryptoKey
  
  beforeEach(async () => {
    encryptionKey = await generateKey()
  })
  
  describe('encryptData / decryptData', () => {
    it('should encrypt and decrypt string successfully', async () => {
      const originalData = 'Hello, this is sensitive data!'
      
      const encrypted = await encryptData(originalData, encryptionKey)
      expect(encrypted).not.toBe(originalData)
      expect(encrypted.length).toBeGreaterThan(originalData.length)
      
      const decrypted = await decryptData(encrypted, encryptionKey)
      expect(decrypted).toBe(originalData)
    })
    
    it('should produce different ciphertext for same input (IV randomization)', async () => {
      const data = 'Same input data'
      
      const encrypted1 = await encryptData(data, encryptionKey)
      const encrypted2 = await encryptData(data, encryptionKey)
      
      expect(encrypted1).not.toBe(encrypted2) // Different IVs
      
      const decrypted1 = await decryptData(encrypted1, encryptionKey)
      const decrypted2 = await decryptData(encrypted2, encryptionKey)
      
      expect(decrypted1).toBe(data)
      expect(decrypted2).toBe(data)
    })
    
    it('should handle unicode characters', async () => {
      const unicodeData = '‰Ω†Â•Ω üöÄ –ü—Ä–∏–≤–µ—Ç'
      
      const encrypted = await encryptData(unicodeData, encryptionKey)
      const decrypted = await decryptData(encrypted, encryptionKey)
      
      expect(decrypted).toBe(unicodeData)
    })
  })
  
  describe('encryptObject / decryptObject', () => {
    it('should encrypt and decrypt objects', async () => {
      const obj = {
        name: 'John Doe',
        email: 'john@example.com',
        nested: { value: 123 }
      }
      
      const encrypted = await encryptObject(obj, encryptionKey)
      expect(encrypted).toBeTypeOf('string')
      expect(encrypted).not.toContain('John Doe') // Not plaintext
      
      const decrypted = await decryptObject(encrypted, encryptionKey)
      expect(decrypted).toEqual(obj)
    })
  })
  
  describe('key generation', () => {
    it('should generate consistent key for same device', async () => {
      const key1 = await generateKey()
      const key2 = await generateKey()
      
      // Should be able to decrypt with either key (same device)
      const data = 'Test data'
      const encrypted = await encryptData(data, key1)
      const decrypted = await decryptData(encrypted, key2)
      
      expect(decrypted).toBe(data)
    })
  })
})
```

**File: tests/unit/storage/profile-storage.test.ts**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { saveProfile, loadProfile, deleteProfile, exportData, hasProfile } from '@/lib/storage/profile-storage'
import type { Profile } from '@/types/profile'

// Mock chrome.storage.local
const mockStorage: Record<string, any> = {}

global.chrome = {
  storage: {
    local: {
      get: vi.fn((keys) => {
        if (typeof keys === 'string') {
          return Promise.resolve({ [keys]: mockStorage[keys] })
        }
        const result: Record<string, any> = {}
        keys.forEach((key: string) => {
          if (mockStorage[key]) result[key] = mockStorage[key]
        })
        return Promise.resolve(result)
      }),
      set: vi.fn((items) => {
        Object.assign(mockStorage, items)
        return Promise.resolve()
      }),
      clear: vi.fn(() => {
        Object.keys(mockStorage).forEach(key => delete mockStorage[key])
        return Promise.resolve()
      })
    }
  }
} as any

describe('profile-storage', () => {
  const sampleProfile: Profile = {
    personal: {
      name: 'Jane Smith',
      email: 'jane@example.com',
      phone: '555-1234',
      location: 'San Francisco, CA'
    },
    workHistory: [
      {
        id: '1',
        position: 'Engineer',
        company: 'Tech Co',
        startDate: '2020-01',
        endDate: 'Present',
        achievements: ['Built things']
      }
    ],
    education: [],
    skills: [{ name: 'JavaScript' }, { name: 'TypeScript' }],
    links: { github: 'https://github.com/jane' },
    domainExtras: {},
    rolePreference: 'Tech',
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z'
  }
  
  beforeEach(() => {
    // Clear mock storage
    Object.keys(mockStorage).forEach(key => delete mockStorage[key])
  })
  
  describe('saveProfile / loadProfile', () => {
    it('should save and load profile with encryption', async () => {
      await saveProfile(sampleProfile)
      
      // Verify storage contains encrypted data (not plaintext)
      const storedData = mockStorage['encrypted_profile']
      expect(storedData).toBeDefined()
      expect(storedData).not.toContain('Jane Smith') // Not plaintext
      
      // Load and verify decryption
      const loadedProfile = await loadProfile()
      expect(loadedProfile).toEqual(sampleProfile)
    })
    
    it('should return null when no profile exists', async () => {
      const profile = await loadProfile()
      expect(profile).toBeNull()
    })
  })
  
  describe('deleteProfile', () => {
    it('should delete all data from storage (REQ-PRO-06)', async () => {
      await saveProfile(sampleProfile)
      expect(await hasProfile()).toBe(true)
      
      await deleteProfile()
      
      expect(await hasProfile()).toBe(false)
      expect(Object.keys(mockStorage).length).toBe(0)
    })
  })
  
  describe('exportData', () => {
    it('should export decrypted profile as JSON (REQ-PRO-06)', async () => {
      await saveProfile(sampleProfile)
      
      const exported = await exportData()
      
      expect(exported.profile).toEqual(sampleProfile)
      expect(exported.applications).toEqual([])
      expect(exported.exportedAt).toBeTruthy()
    })
  })
  
  describe('hasProfile', () => {
    it('should detect profile existence', async () => {
      expect(await hasProfile()).toBe(false)
      
      await saveProfile(sampleProfile)
      
      expect(await hasProfile()).toBe(true)
    })
  })
})
```

Add JSDoc comments explaining test coverage for REQ-PRO-05 and REQ-PRO-06.
  </action>
  <verify>
Run `pnpm test` - all storage tests must pass.
Verify encryption test proves data is not plaintext.
Verify profile storage test proves persistence across save/load cycles.
  </verify>
  <done>
Storage tests passing with encryption validation and profile persistence verification. Coverage includes REQ-PRO-05 (encryption) and REQ-PRO-06 (export/delete).
  </done>
</task>

</tasks>

<verification>
**Encryption Functionality:**
- [ ] Web Crypto API AES-GCM encryption working
- [ ] Encrypted data is not plaintext (verified by test)
- [ ] Decryption recovers original data correctly
- [ ] Key generation consistent for same device

**Profile Storage:**
- [ ] Profile saved encrypted to Chrome Storage
- [ ] Profile loads correctly after save
- [ ] Profile persists across mock "browser restart"
- [ ] Delete clears all storage
- [ ] Export produces valid JSON with decrypted data

**Code Quality:**
- [ ] `pnpm type-check` passes
- [ ] `pnpm test` passes with all storage tests
- [ ] No external encryption libraries added (Web Crypto API only)

**Requirements Coverage:**
- [ ] REQ-PRO-05: Encrypted local storage implemented and tested
- [ ] REQ-PRO-06: Data export and delete implemented and tested
</verification>

<success_criteria>
- Web Crypto API encryption module fully functional
- Profile storage with automatic encryption working
- Encrypted data in Chrome Storage (not plaintext)
- Profile persists across sessions
- Export produces decrypted JSON
- Delete clears all data irreversibly
- Unit tests validate encryption and storage operations
- Zero external dependencies (Web Crypto API + Chrome Storage API)
</success_criteria>

<output>
After completion, create `.planning/phases/01-profile-management-resume-parsing/01-03-SUMMARY.md` following the standard summary template.
</output>
