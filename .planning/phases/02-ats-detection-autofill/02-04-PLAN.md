---
phase: 02-ats-detection-autofill
plan: 04
type: execute
wave: 4
depends_on: ['02-03']
files_modified:
  - src/lib/autofill/engine.ts
  - src/lib/autofill/field-filler.ts
  - src/lib/autofill/undo-manager.ts
  - tests/unit/autofill/engine.test.ts
autonomous: true

must_haves:
  truths:
    - "One-click autofill fills all mapped fields with confidence ≥70%"
    - "Field filling fires proper DOM events (input, change, blur)"
    - "Per-field undo functionality works"
    - "Undo All restores all fields to original state"
  artifacts:
    - path: "src/lib/autofill/engine.ts"
      provides: "Main autofill orchestrator with validation"
      exports: ["AutofillEngine", "autofillForm"]
      min_lines: 150
    - path: "src/lib/autofill/field-filler.ts"
      provides: "Low-level DOM manipulation for field filling"
      exports: ["fillField", "getFieldValue", "setFieldValue"]
      min_lines: 120
    - path: "src/lib/autofill/undo-manager.ts"
      provides: "Undo/redo system for field changes"
      exports: ["UndoManager"]
      min_lines: 100
    - path: "tests/unit/autofill/engine.test.ts"
      provides: "Autofill engine tests"
      exports: []
      min_lines: 150
  key_links:
    - from: "src/lib/autofill/engine.ts"
      to: "@/lib/autofill/field-mapper"
      via: "Uses mapFieldsToProfile"
      pattern: "mapFieldsToProfile"
    - from: "src/lib/autofill/field-filler.ts"
      to: "@/types/autofill"
      via: "Fills DetectedField elements"
      pattern: "DetectedField"
---

<objective>
Build autofill engine that fills form fields with profile data, fires proper events, and supports undo/redo.

**Purpose:** Implement one-click autofill that fills all mapped fields with proper DOM event firing (input, change, blur) so ATS forms recognize the changes. Includes per-field undo and Undo All functionality (REQ-ATS-10, REQ-ATS-11, REQ-ATS-12).

**Output:** Fully functional autofill engine with field validation, event firing, and undo system.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-ats-detection-autofill/02-00-OVERVIEW.md
@.planning/phases/02-ats-detection-autofill/02-01-PLAN.md
@.planning/phases/02-ats-detection-autofill/02-02-PLAN.md
@.planning/phases/02-ats-detection-autofill/02-03-PLAN.md
@TECHSTACK.md
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Field Filler</name>
  <files>src/lib/autofill/field-filler.ts</files>
  <action>
Create `src/lib/autofill/field-filler.ts` for low-level field filling with event firing:

**Implementation approach:**
- Set field values using proper DOM APIs
- Fire all necessary events (input, change, blur) for ATS form validation
- Handle different field types (input, select, textarea)
- Validate field values before filling
- Handle React/Vue controlled inputs

```typescript
import type { DetectedField, FieldType } from '@/types/autofill';

/**
 * Fill a form field with a value
 * Fires proper DOM events so ATS forms recognize the change
 *
 * @param field - Detected form field
 * @param value - Value to fill
 * @returns Success boolean
 */
export function fillField(field: DetectedField, value: string): boolean {
  try {
    const element = field.element;

    // Store original value for undo
    const originalValue = getFieldValue(element);

    // Validate value before filling
    if (!validateValue(field, value)) {
      console.warn('[FieldFiller] Invalid value for field:', field.label, value);
      return false;
    }

    // Set value based on field type
    const success = setFieldValue(element, value, field.type);
    if (!success) return false;

    // Fire events to trigger ATS validation
    fireFieldEvents(element);

    console.log('[FieldFiller] Filled field:', field.label, value);
    return true;
  } catch (error) {
    console.error('[FieldFiller] Error filling field:', error);
    return false;
  }
}

/**
 * Get current field value
 */
export function getFieldValue(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
): string {
  if (element instanceof HTMLSelectElement) {
    return element.value;
  }

  if (element instanceof HTMLInputElement) {
    if (element.type === 'checkbox') {
      return element.checked ? 'true' : 'false';
    }
    if (element.type === 'radio') {
      return element.checked ? element.value : '';
    }
  }

  return element.value;
}

/**
 * Set field value with proper handling for different field types
 */
export function setFieldValue(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,
  value: string,
  type: FieldType
): boolean {
  try {
    if (element instanceof HTMLSelectElement) {
      return setSelectValue(element, value);
    }

    if (element instanceof HTMLInputElement) {
      return setInputValue(element, value, type);
    }

    if (element instanceof HTMLTextAreaElement) {
      return setTextareaValue(element, value);
    }

    return false;
  } catch (error) {
    console.error('[FieldFiller] Error setting value:', error);
    return false;
  }
}

/**
 * Set input field value
 */
function setInputValue(element: HTMLInputElement, value: string, type: FieldType): boolean {
  switch (type) {
    case 'checkbox':
      element.checked = value === 'true' || value === '1';
      return true;

    case 'radio':
      if (element.value === value) {
        element.checked = true;
        return true;
      }
      return false;

    case 'file':
      // Cannot programmatically set file inputs
      console.warn('[FieldFiller] Cannot autofill file input');
      return false;

    default:
      // For React/Vue compatibility, set both value and native value
      setNativeValue(element, value);
      return true;
  }
}

/**
 * Set select field value
 */
function setSelectValue(element: HTMLSelectElement, value: string): boolean {
  // Try exact match first
  const exactOption = Array.from(element.options).find(
    (opt) => opt.value === value || opt.textContent?.trim() === value
  );

  if (exactOption) {
    element.value = exactOption.value;
    return true;
  }

  // Try fuzzy match (case-insensitive)
  const fuzzyOption = Array.from(element.options).find(
    (opt) =>
      opt.value.toLowerCase().includes(value.toLowerCase()) ||
      opt.textContent?.toLowerCase().includes(value.toLowerCase())
  );

  if (fuzzyOption) {
    element.value = fuzzyOption.value;
    return true;
  }

  console.warn('[FieldFiller] No matching option found in select:', value);
  return false;
}

/**
 * Set textarea value
 */
function setTextareaValue(element: HTMLTextAreaElement, value: string): boolean {
  setNativeValue(element, value);
  return true;
}

/**
 * Set native value for React/Vue compatibility
 * React uses a setter on the prototype to track changes
 */
function setNativeValue(element: HTMLInputElement | HTMLTextAreaElement, value: string): void {
  const valueSetter = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(element),
    'value'
  )?.set;

  if (valueSetter) {
    valueSetter.call(element, value);
  } else {
    element.value = value;
  }
}

/**
 * Fire DOM events to trigger ATS form validation
 * Must fire in correct order: focus -> input -> change -> blur
 */
function fireFieldEvents(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
): void {
  // Focus event (if element not already focused)
  if (document.activeElement !== element) {
    element.dispatchEvent(new FocusEvent('focus', { bubbles: true }));
  }

  // Input event (fired during typing)
  element.dispatchEvent(
    new InputEvent('input', {
      bubbles: true,
      cancelable: true,
      composed: true,
    })
  );

  // Change event (fired when value changes)
  element.dispatchEvent(
    new Event('change', {
      bubbles: true,
      cancelable: true,
    })
  );

  // Blur event (field loses focus)
  element.dispatchEvent(new FocusEvent('blur', { bubbles: true }));

  // Also fire React synthetic events if present
  const reactKey = Object.keys(element).find((key) => key.startsWith('__reactProps'));
  if (reactKey) {
    // Trigger React re-render by directly calling onChange if present
    const reactProps = (element as any)[reactKey];
    if (reactProps?.onChange) {
      reactProps.onChange({ target: element, currentTarget: element });
    }
  }
}

/**
 * Validate value before filling
 */
function validateValue(field: DetectedField, value: string): boolean {
  // Empty value check
  if (!value || value.trim() === '') {
    return false;
  }

  // Type-specific validation
  switch (field.type) {
    case 'email':
      return isValidEmail(value);

    case 'phone':
      return isValidPhone(value);

    case 'url':
      return isValidURL(value);

    case 'date':
      return isValidDate(value);

    default:
      return true;
  }
}

/**
 * Email validation
 */
function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Phone validation (basic)
 */
function isValidPhone(phone: string): boolean {
  // Accept various formats: 555-1234, (555) 123-4567, +1 555 123 4567
  const phoneRegex = /^[\d\s\-\(\)\+]+$/;
  return phoneRegex.test(phone) && phone.replace(/\D/g, '').length >= 7;
}

/**
 * URL validation
 */
function isValidURL(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Date validation
 */
function isValidDate(date: string): boolean {
  // Accept YYYY-MM-DD or MM/DD/YYYY or other formats
  const parsed = Date.parse(date);
  return !isNaN(parsed);
}

/**
 * Clear field value
 */
export function clearField(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
): void {
  if (element instanceof HTMLInputElement && element.type === 'checkbox') {
    element.checked = false;
  } else {
    setFieldValue(element, '', 'text');
  }
  fireFieldEvents(element);
}
```

**Commit:** `feat(02-04): create field filler with event firing`
  </action>
</task>

<task type="auto">
  <name>Task 2: Create Undo Manager</name>
  <files>src/lib/autofill/undo-manager.ts</files>
  <action>
Create `src/lib/autofill/undo-manager.ts` for undo/redo functionality:

**Implementation approach:**
- Track original field values before filling
- Store undo history per field
- Provide undo single field and undo all
- Limit history size to prevent memory issues

```typescript
import type { DetectedField } from '@/types/autofill';
import { getFieldValue, setFieldValue, fireFieldEvents } from './field-filler';

/**
 * Undo history entry
 */
interface UndoEntry {
  field: DetectedField;
  originalValue: string;
  newValue: string;
  timestamp: number;
}

/**
 * Undo manager for autofill operations
 * Tracks original values and allows reverting changes
 */
export class UndoManager {
  private history: Map<HTMLElement, UndoEntry> = new Map();
  private maxHistorySize = 100;

  /**
   * Record a field change for undo
   */
  record(field: DetectedField, originalValue: string, newValue: string): void {
    const entry: UndoEntry = {
      field,
      originalValue,
      newValue,
      timestamp: Date.now(),
    };

    this.history.set(field.element, entry);

    // Limit history size
    if (this.history.size > this.maxHistorySize) {
      const oldestKey = Array.from(this.history.keys())[0];
      this.history.delete(oldestKey);
    }
  }

  /**
   * Undo a single field change
   */
  undoField(element: HTMLElement): boolean {
    const entry = this.history.get(element);
    if (!entry) {
      console.warn('[UndoManager] No undo history for field');
      return false;
    }

    try {
      // Restore original value
      const success = setFieldValue(entry.field.element, entry.originalValue, entry.field.type);
      if (!success) return false;

      // Fire events
      fireFieldEvents(entry.field.element);

      // Remove from history
      this.history.delete(element);

      console.log('[UndoManager] Undone field:', entry.field.label);
      return true;
    } catch (error) {
      console.error('[UndoManager] Error undoing field:', error);
      return false;
    }
  }

  /**
   * Undo all field changes
   */
  undoAll(): number {
    let undoneCount = 0;

    for (const [element, entry] of this.history.entries()) {
      try {
        const success = setFieldValue(entry.field.element, entry.originalValue, entry.field.type);
        if (success) {
          fireFieldEvents(entry.field.element);
          undoneCount++;
        }
      } catch (error) {
        console.error('[UndoManager] Error undoing field:', error);
      }
    }

    // Clear history
    this.history.clear();

    console.log('[UndoManager] Undone all fields:', undoneCount);
    return undoneCount;
  }

  /**
   * Get undo entry for a field
   */
  getEntry(element: HTMLElement): UndoEntry | undefined {
    return this.history.get(element);
  }

  /**
   * Check if field has undo history
   */
  hasUndo(element: HTMLElement): boolean {
    return this.history.has(element);
  }

  /**
   * Get count of undoable fields
   */
  getUndoCount(): number {
    return this.history.size;
  }

  /**
   * Clear all history
   */
  clear(): void {
    this.history.clear();
  }

  /**
   * Get all entries (for debugging)
   */
  getAllEntries(): UndoEntry[] {
    return Array.from(this.history.values());
  }
}
```

**Commit:** `feat(02-04): create undo manager for field changes`
  </action>
</task>

<task type="auto">
  <name>Task 3: Create Autofill Engine</name>
  <files>src/lib/autofill/engine.ts</files>
  <action>
Create `src/lib/autofill/engine.ts` as the main autofill orchestrator:

**Implementation approach:**
- Coordinate field mapping and filling
- Use UndoManager to track changes
- Provide progress callbacks
- Handle errors gracefully
- Validate fields before filling

```typescript
import type { Profile } from '@/types/profile';
import type { FieldMapping, FormMappingResult } from '@/types/autofill';
import type { ATSType } from '@/types/ats';
import { mapFieldsToProfile } from './field-mapper';
import { fillField, getFieldValue } from './field-filler';
import { UndoManager } from './undo-manager';
import { CONFIDENCE_THRESHOLDS } from '@/constants/field-selectors';

/**
 * Autofill result
 */
export interface AutofillResult {
  success: boolean;
  filledCount: number;
  skippedCount: number;
  errorCount: number;
  errors: Array<{ field: string; error: string }>;
  undoManager: UndoManager;
}

/**
 * Autofill options
 */
export interface AutofillOptions {
  /** Only fill fields with confidence >= this threshold (default: 70) */
  minConfidence?: number;
  /** Container element to search for fields (default: document) */
  container?: HTMLElement | Document;
  /** Callback for progress updates */
  onProgress?: (current: number, total: number, fieldName: string) => void;
  /** Callback for field filled */
  onFieldFilled?: (mapping: FieldMapping) => void;
  /** Callback for field skipped */
  onFieldSkipped?: (mapping: FieldMapping, reason: string) => void;
}

/**
 * Main autofill engine class
 */
export class AutofillEngine {
  private undoManager: UndoManager;
  private profile: Profile | null = null;
  private atsType: ATSType | null = null;

  constructor() {
    this.undoManager = new UndoManager();
  }

  /**
   * Set user profile
   */
  setProfile(profile: Profile): void {
    this.profile = profile;
  }

  /**
   * Set ATS type
   */
  setATSType(atsType: ATSType): void {
    this.atsType = atsType;
  }

  /**
   * Run autofill on current form
   */
  async autofill(options: AutofillOptions = {}): Promise<AutofillResult> {
    if (!this.profile) {
      throw new Error('Profile not set. Call setProfile() first.');
    }

    const {
      minConfidence = CONFIDENCE_THRESHOLDS.MEDIUM,
      container = document,
      onProgress,
      onFieldFilled,
      onFieldSkipped,
    } = options;

    console.log('[AutofillEngine] Starting autofill...');

    // Map fields to profile
    const mappingResult = mapFieldsToProfile(this.profile, container);
    console.log('[AutofillEngine] Mapped fields:', mappingResult);

    // Filter mappings to fill (confidence >= threshold, has value)
    const fillableMappings = mappingResult.mappings.filter(
      (m) => m.shouldFill && m.confidence >= minConfidence
    );

    console.log('[AutofillEngine] Fillable fields:', fillableMappings.length);

    const result: AutofillResult = {
      success: true,
      filledCount: 0,
      skippedCount: 0,
      errorCount: 0,
      errors: [],
      undoManager: this.undoManager,
    };

    // Fill each field
    for (let i = 0; i < fillableMappings.length; i++) {
      const mapping = fillableMappings[i];

      // Progress callback
      if (onProgress) {
        onProgress(i + 1, fillableMappings.length, mapping.field.label || 'Unknown field');
      }

      try {
        // Get original value for undo
        const originalValue = getFieldValue(mapping.field.element);

        // Fill field
        const success = fillField(mapping.field, mapping.value!);

        if (success) {
          // Record for undo
          this.undoManager.record(mapping.field, originalValue, mapping.value!);

          result.filledCount++;

          if (onFieldFilled) {
            onFieldFilled(mapping);
          }
        } else {
          result.skippedCount++;

          if (onFieldSkipped) {
            onFieldSkipped(mapping, 'Fill failed');
          }
        }
      } catch (error) {
        result.errorCount++;
        result.errors.push({
          field: mapping.field.label || 'Unknown',
          error: error instanceof Error ? error.message : String(error),
        });

        if (onFieldSkipped) {
          onFieldSkipped(mapping, 'Error occurred');
        }
      }
    }

    console.log('[AutofillEngine] Autofill complete:', result);
    return result;
  }

  /**
   * Undo a single field
   */
  undoField(element: HTMLElement): boolean {
    return this.undoManager.undoField(element);
  }

  /**
   * Undo all filled fields
   */
  undoAll(): number {
    return this.undoManager.undoAll();
  }

  /**
   * Get undo manager
   */
  getUndoManager(): UndoManager {
    return this.undoManager;
  }

  /**
   * Check if field can be undone
   */
  canUndo(element: HTMLElement): boolean {
    return this.undoManager.hasUndo(element);
  }

  /**
   * Get count of undoable fields
   */
  getUndoCount(): number {
    return this.undoManager.getUndoCount();
  }

  /**
   * Reset engine state
   */
  reset(): void {
    this.undoManager.clear();
    this.profile = null;
    this.atsType = null;
  }
}

/**
 * Convenience function for one-shot autofill
 */
export async function autofillForm(
  profile: Profile,
  options: AutofillOptions = {}
): Promise<AutofillResult> {
  const engine = new AutofillEngine();
  engine.setProfile(profile);
  return engine.autofill(options);
}
```

**Commit:** `feat(02-04): create autofill engine orchestrator`
  </action>
</task>

<task type="auto">
  <name>Task 4: Create Autofill Engine Tests</name>
  <files>tests/unit/autofill/engine.test.ts</files>
  <action>
Create tests for autofill engine:

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { AutofillEngine, autofillForm } from '@/lib/autofill/engine';
import { fillField, getFieldValue } from '@/lib/autofill/field-filler';
import type { Profile } from '@/types/profile';

describe('Autofill Engine', () => {
  let mockProfile: Profile;
  let testForm: HTMLFormElement;

  beforeEach(() => {
    mockProfile = {
      firstName: 'Jane',
      lastName: 'Smith',
      email: 'jane@example.com',
      phone: '555-9876',
      currentCompany: 'Tech Corp',
    } as Profile;

    // Create test form
    testForm = createTestForm();
    document.body.appendChild(testForm);
  });

  afterEach(() => {
    if (testForm.parentNode) {
      document.body.removeChild(testForm);
    }
  });

  describe('Field Filling', () => {
    it('should fill all mappable fields', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      const result = await engine.autofill({ container: testForm });

      expect(result.success).toBe(true);
      expect(result.filledCount).toBeGreaterThan(0);
      expect(result.errorCount).toBe(0);

      // Verify values
      const firstNameInput = testForm.querySelector<HTMLInputElement>('#firstName');
      expect(firstNameInput?.value).toBe('Jane');

      const emailInput = testForm.querySelector<HTMLInputElement>('#email');
      expect(emailInput?.value).toBe('jane@example.com');
    });

    it('should fire DOM events on filled fields', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      const input = testForm.querySelector<HTMLInputElement>('#firstName')!;
      let inputEventFired = false;
      let changeEventFired = false;

      input.addEventListener('input', () => {
        inputEventFired = true;
      });
      input.addEventListener('change', () => {
        changeEventFired = true;
      });

      await engine.autofill({ container: testForm });

      expect(inputEventFired).toBe(true);
      expect(changeEventFired).toBe(true);
    });

    it('should respect minimum confidence threshold', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      // Fill with high confidence only (≥80%)
      const result = await engine.autofill({
        container: testForm,
        minConfidence: 80,
      });

      // Should have fewer filled fields than with default threshold (70%)
      const resultWithLowerThreshold = await engine.autofill({
        container: testForm,
        minConfidence: 70,
      });

      expect(result.filledCount).toBeLessThanOrEqual(resultWithLowerThreshold.filledCount);
    });
  });

  describe('Undo Functionality', () => {
    it('should undo single field', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      const input = testForm.querySelector<HTMLInputElement>('#firstName')!;
      const originalValue = input.value;

      await engine.autofill({ container: testForm });

      expect(input.value).toBe('Jane');

      // Undo
      const undone = engine.undoField(input);
      expect(undone).toBe(true);
      expect(input.value).toBe(originalValue);
    });

    it('should undo all fields', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      const firstNameInput = testForm.querySelector<HTMLInputElement>('#firstName')!;
      const emailInput = testForm.querySelector<HTMLInputElement>('#email')!;

      const originalFirstName = firstNameInput.value;
      const originalEmail = emailInput.value;

      await engine.autofill({ container: testForm });

      expect(firstNameInput.value).toBe('Jane');
      expect(emailInput.value).toBe('jane@example.com');

      // Undo all
      const undoneCount = engine.undoAll();
      expect(undoneCount).toBeGreaterThan(0);

      expect(firstNameInput.value).toBe(originalFirstName);
      expect(emailInput.value).toBe(originalEmail);
    });

    it('should track undo count', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      expect(engine.getUndoCount()).toBe(0);

      await engine.autofill({ container: testForm });

      expect(engine.getUndoCount()).toBeGreaterThan(0);

      engine.undoAll();

      expect(engine.getUndoCount()).toBe(0);
    });
  });

  describe('Progress Callbacks', () => {
    it('should call onProgress callback', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      const progressUpdates: number[] = [];

      await engine.autofill({
        container: testForm,
        onProgress: (current, total) => {
          progressUpdates.push(current);
        },
      });

      expect(progressUpdates.length).toBeGreaterThan(0);
    });

    it('should call onFieldFilled callback', async () => {
      const engine = new AutofillEngine();
      engine.setProfile(mockProfile);

      const filledFields: string[] = [];

      await engine.autofill({
        container: testForm,
        onFieldFilled: (mapping) => {
          filledFields.push(mapping.field.label || '');
        },
      });

      expect(filledFields.length).toBeGreaterThan(0);
    });
  });
});

/**
 * Create test form
 */
function createTestForm(): HTMLFormElement {
  const form = document.createElement('form');

  const fields = [
    { id: 'firstName', label: 'First Name', type: 'text' },
    { id: 'lastName', label: 'Last Name', type: 'text' },
    { id: 'email', label: 'Email', type: 'email' },
    { id: 'phone', label: 'Phone', type: 'tel' },
    { id: 'company', label: 'Company', type: 'text' },
  ];

  for (const field of fields) {
    const label = document.createElement('label');
    label.htmlFor = field.id;
    label.textContent = field.label;

    const input = document.createElement('input');
    input.type = field.type;
    input.id = field.id;
    input.name = field.id;

    form.appendChild(label);
    form.appendChild(input);
  }

  return form;
}
```

**Commit:** `feat(02-04): create autofill engine tests`
  </action>
</task>

</tasks>

<verification>
- [ ] Field filler sets values correctly for all field types
- [ ] DOM events fired in correct order (focus, input, change, blur)
- [ ] React/Vue controlled inputs work (uses native value setter)
- [ ] Field validation prevents invalid values
- [ ] Undo single field restores original value
- [ ] Undo all restores all fields
- [ ] Progress callbacks work
- [ ] TypeScript compiles without errors
- [ ] Unit tests pass
</verification>

<success_criteria>
- ✅ One-click autofill fills all mapped fields (confidence ≥70%)
- ✅ Field filling fires proper DOM events (input, change, blur)
- ✅ React/Vue compatibility (native value setter)
- ✅ Per-field undo functionality works
- ✅ Undo All restores entire form
- ✅ Field validation prevents invalid data
- ✅ Progress and completion callbacks
- ✅ Error handling with detailed error messages
</success_criteria>

<next_steps>
After completing this plan:
1. Test autofill on real ATS forms (Workday, Greenhouse, Lever)
2. Verify events trigger ATS validation
3. Test undo on partially filled forms
4. Move to Plan 02-05: Autofill Button UI & Visual Feedback
</next_steps>

---

*Plan: 02-04-Autofill-Engine*
*Priority: P0*
*Duration: 60 minutes*
