---
phase: 02-ats-detection-autofill
plan: 03
type: execute
wave: 3
depends_on: ['02-02']
files_modified:
  - package.json
  - src/lib/autofill/field-mapper.ts
  - src/lib/autofill/confidence-scorer.ts
  - src/lib/autofill/field-detector.ts
  - src/constants/field-selectors.ts
  - tests/unit/autofill/field-mapper.test.ts
autonomous: true

must_haves:
  truths:
    - "Field mapper achieves ≥85% accuracy on standard form fields"
    - "Confidence scoring uses fuzzy matching with Fuse.js"
    - "Multi-strategy detection (label, aria-label, name, id, placeholder)"
    - "Low-confidence fields (<70%) flagged for manual review"
  artifacts:
    - path: "src/lib/autofill/field-mapper.ts"
      provides: "Field mapping orchestrator with ≥85% accuracy"
      exports: ["mapFieldsToProfile", "FieldMapping"]
      min_lines: 150
    - path: "src/lib/autofill/confidence-scorer.ts"
      provides: "Fuzzy string matching and confidence calculation"
      exports: ["calculateFieldConfidence", "fuzzyMatch"]
      min_lines: 100
    - path: "src/lib/autofill/field-detector.ts"
      provides: "Field type detection (text, email, phone, date, select)"
      exports: ["detectFieldType", "FieldType"]
      min_lines: 120
    - path: "src/constants/field-selectors.ts"
      provides: "Field type patterns and keywords for matching"
      exports: ["FIELD_KEYWORDS", "FIELD_PATTERNS"]
      min_lines: 80
    - path: "tests/unit/autofill/field-mapper.test.ts"
      provides: "Field mapping accuracy tests (≥85% target)"
      exports: []
      min_lines: 200
  key_links:
    - from: "src/lib/autofill/field-mapper.ts"
      to: "@/types/profile"
      via: "Maps Profile fields to form fields"
      pattern: "Profile"
    - from: "src/lib/autofill/confidence-scorer.ts"
      to: "fuse.js"
      via: "Uses Fuse.js for fuzzy matching"
      pattern: "Fuse"
---

<objective>
Build intelligent field mapping engine with ≥85% accuracy using fuzzy matching and confidence scoring.

**Purpose:** Map detected form fields to user profile data using multi-strategy detection (label, aria-label, name, id, placeholder) with confidence scoring. Fields below 70% confidence flagged for manual review (REQ-ATS-07, REQ-ATS-08, REQ-ATS-09).

**Output:** Field mapper that accurately maps profile data to form fields with confidence scores, using Fuse.js for fuzzy string matching.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-ats-detection-autofill/02-00-OVERVIEW.md
@.planning/phases/02-ats-detection-autofill/02-01-PLAN.md
@.planning/phases/02-ats-detection-autofill/02-02-PLAN.md
@TECHSTACK.md
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Fuse.js</name>
  <files>package.json</files>
  <action>
Install Fuse.js for fuzzy string matching:

```bash
pnpm add fuse.js
```

Verify installation:
```bash
pnpm list fuse.js
```

**Commit:** `feat(02-03): install fuse.js for fuzzy field matching`
  </action>
</task>

<task type="auto">
  <name>Task 2: Create Field Type Definitions</name>
  <files>src/types/autofill.ts</files>
  <action>
Create `src/types/autofill.ts` for field mapping types:

```typescript
import type { Profile } from './profile';

/**
 * Form field types
 */
export type FieldType =
  | 'text'
  | 'email'
  | 'phone'
  | 'url'
  | 'date'
  | 'select'
  | 'textarea'
  | 'checkbox'
  | 'radio'
  | 'file'
  | 'unknown';

/**
 * Profile field categories
 */
export type ProfileFieldCategory =
  | 'contact'
  | 'personal'
  | 'work_history'
  | 'education'
  | 'skills'
  | 'links'
  | 'other';

/**
 * Detected form field with metadata
 */
export interface DetectedField {
  /** The input element */
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;
  /** Detected field type */
  type: FieldType;
  /** Field label text */
  label: string | null;
  /** Placeholder text */
  placeholder: string | null;
  /** Name attribute */
  name: string | null;
  /** ID attribute */
  id: string | null;
  /** ARIA label */
  ariaLabel: string | null;
  /** Is required field */
  required: boolean;
  /** Current value */
  currentValue: string;
}

/**
 * Field mapping result
 */
export interface FieldMapping {
  /** Detected form field */
  field: DetectedField;
  /** Mapped profile field key */
  profileKey: keyof Profile | null;
  /** Value to fill */
  value: string | null;
  /** Confidence score (0-100) */
  confidence: number;
  /** Should this field be filled automatically? */
  shouldFill: boolean;
  /** Reason for low confidence (if any) */
  reason?: string;
}

/**
 * Field mapping result for entire form
 */
export interface FormMappingResult {
  /** All detected fields */
  fields: DetectedField[];
  /** Field mappings */
  mappings: FieldMapping[];
  /** Overall confidence (average) */
  overallConfidence: number;
  /** Number of fields that can be filled */
  fillableCount: number;
  /** Number of fields requiring manual review */
  manualReviewCount: number;
}

/**
 * Field matching strategy
 */
export type MatchStrategy = 'label' | 'placeholder' | 'name' | 'id' | 'ariaLabel';

/**
 * Match result from a strategy
 */
export interface MatchResult {
  /** Strategy used */
  strategy: MatchStrategy;
  /** Matched profile key */
  profileKey: keyof Profile;
  /** Match score (0-1) */
  score: number;
  /** Matched text */
  matchedText: string;
}
```

**Commit:** `feat(02-03): create field mapping type definitions`
  </action>
</task>

<task type="auto">
  <name>Task 3: Create Field Keywords and Patterns</name>
  <files>src/constants/field-selectors.ts</files>
  <action>
Create `src/constants/field-selectors.ts` with field keywords for matching:

```typescript
import type { Profile } from '@/types/profile';

/**
 * Keywords for each profile field
 * Used for fuzzy matching against form field labels/names/placeholders
 */
export const FIELD_KEYWORDS: Record<keyof Profile, string[]> = {
  // Contact
  firstName: ['first name', 'given name', 'forename', 'fname'],
  lastName: ['last name', 'surname', 'family name', 'lname'],
  email: ['email', 'e-mail', 'email address', 'contact email'],
  phone: ['phone', 'telephone', 'mobile', 'cell', 'phone number', 'contact number'],
  
  // Personal
  address: ['address', 'street address', 'home address', 'mailing address'],
  city: ['city', 'town', 'locality'],
  state: ['state', 'province', 'region'],
  zipCode: ['zip', 'zip code', 'postal code', 'postcode'],
  country: ['country'],
  
  // Professional
  linkedinUrl: ['linkedin', 'linkedin profile', 'linkedin url'],
  githubUrl: ['github', 'github profile', 'github username'],
  portfolioUrl: ['portfolio', 'website', 'personal site', 'personal website'],
  
  // Work history
  workHistory: ['work history', 'work experience', 'employment', 'experience', 'resume'],
  currentCompany: ['current company', 'employer', 'current employer'],
  currentTitle: ['current title', 'job title', 'current position', 'position'],
  yearsOfExperience: ['years of experience', 'experience', 'years experience', 'yoe'],
  
  // Education
  education: ['education', 'educational background', 'degrees'],
  degree: ['degree', 'education level', 'highest degree'],
  university: ['university', 'college', 'school', 'institution'],
  major: ['major', 'field of study', 'area of study', 'concentration'],
  graduationYear: ['graduation', 'graduation year', 'grad year', 'year graduated'],
  
  // Skills
  skills: ['skills', 'technical skills', 'competencies', 'technologies'],
  rolePreference: ['role', 'role preference', 'preferred role', 'job preference'],
  
  // Other
  profileComplete: [],
  createdAt: [],
  updatedAt: [],
};

/**
 * Regex patterns for field type detection
 */
export const FIELD_PATTERNS: Record<string, RegExp> = {
  email: /^(email|e-mail|mail)/i,
  phone: /^(phone|tel|mobile|cell)/i,
  firstName: /^(first|given|fname)/i,
  lastName: /^(last|sur|family|lname)/i,
  city: /^(city|town|locality)/i,
  state: /^(state|province|region)/i,
  zipCode: /^(zip|postal)/i,
  country: /^country/i,
  linkedin: /linkedin/i,
  github: /github/i,
  portfolio: /(portfolio|website|site)/i,
  url: /^(url|link|website)/i,
  date: /^(date|year|graduation)/i,
  experience: /(experience|years|yoe)/i,
  degree: /degree/i,
  major: /(major|field|area)/i,
  university: /(university|college|school)/i,
  company: /company|employer/i,
  title: /(title|position|role)/i,
  skills: /skills|competenc/i,
  address: /address|street/i,
};

/**
 * Confidence thresholds
 */
export const CONFIDENCE_THRESHOLDS = {
  HIGH: 80,    // ≥80% = auto-fill with high confidence
  MEDIUM: 70,  // 70-79% = auto-fill with medium confidence
  LOW: 50,     // 50-69% = require user review
  SKIP: 0,     // <50% = skip, too uncertain
};

/**
 * Field type detection keywords
 */
export const FIELD_TYPE_KEYWORDS = {
  text: ['name', 'title', 'company', 'position'],
  email: ['email', 'e-mail'],
  phone: ['phone', 'tel', 'mobile', 'cell'],
  url: ['url', 'link', 'website', 'linkedin', 'github', 'portfolio'],
  date: ['date', 'year', 'graduation'],
  select: ['country', 'state', 'degree', 'level'],
  textarea: ['experience', 'skills', 'education', 'summary', 'bio', 'description'],
};
```

**Commit:** `feat(02-03): create field keywords and patterns`
  </action>
</task>

<task type="auto">
  <name>Task 4: Create Confidence Scorer with Fuse.js</name>
  <files>src/lib/autofill/confidence-scorer.ts</files>
  <action>
Create `src/lib/autofill/confidence-scorer.ts` for fuzzy matching:

```typescript
import Fuse from 'fuse.js';
import type { Profile } from '@/types/profile';
import type { DetectedField, MatchResult, MatchStrategy } from '@/types/autofill';
import { FIELD_KEYWORDS } from '@/constants/field-selectors';

/**
 * Calculate confidence score for a field mapping
 * Uses fuzzy matching to compare form field labels with profile field keywords
 */
export function calculateFieldConfidence(
  field: DetectedField,
  profileKey: keyof Profile
): number {
  const matches: MatchResult[] = [];

  // Try each strategy
  const strategies: { text: string | null; strategy: MatchStrategy }[] = [
    { text: field.label, strategy: 'label' },
    { text: field.placeholder, strategy: 'placeholder' },
    { text: field.name, strategy: 'name' },
    { text: field.id, strategy: 'id' },
    { text: field.ariaLabel, strategy: 'ariaLabel' },
  ];

  for (const { text, strategy } of strategies) {
    if (!text) continue;

    const match = fuzzyMatch(text, profileKey);
    if (match) {
      matches.push({
        strategy,
        profileKey,
        score: match.score,
        matchedText: text,
      });
    }
  }

  if (matches.length === 0) return 0;

  // Calculate weighted average (label > ariaLabel > placeholder > name > id)
  const weights: Record<MatchStrategy, number> = {
    label: 1.0,
    ariaLabel: 0.9,
    placeholder: 0.7,
    name: 0.5,
    id: 0.3,
  };

  const weightedSum = matches.reduce(
    (sum, match) => sum + match.score * weights[match.strategy],
    0
  );
  const totalWeight = matches.reduce((sum, match) => sum + weights[match.strategy], 0);

  const confidence = (weightedSum / totalWeight) * 100;
  return Math.round(confidence);
}

/**
 * Fuzzy match field text against profile field keywords
 * Returns match score (0-1) or null if no match
 */
export function fuzzyMatch(
  fieldText: string,
  profileKey: keyof Profile
): { score: number; keyword: string } | null {
  const keywords = FIELD_KEYWORDS[profileKey];
  if (!keywords || keywords.length === 0) return null;

  // Create Fuse instance for fuzzy searching
  const fuse = new Fuse(keywords, {
    includeScore: true,
    threshold: 0.4, // 0 = exact match, 1 = match anything
    distance: 100,
    minMatchCharLength: 2,
  });

  const results = fuse.search(fieldText.toLowerCase());

  if (results.length === 0) return null;

  // Fuse score is 0 (perfect) to 1 (bad), invert it
  const bestMatch = results[0];
  const score = 1 - (bestMatch.score ?? 1);

  return {
    score,
    keyword: bestMatch.item,
  };
}

/**
 * Find best profile field match for a detected field
 * Returns profile key and confidence score
 */
export function findBestMatch(
  field: DetectedField
): { profileKey: keyof Profile; confidence: number } | null {
  const profileKeys = Object.keys(FIELD_KEYWORDS) as (keyof Profile)[];
  const matches: { profileKey: keyof Profile; confidence: number }[] = [];

  for (const profileKey of profileKeys) {
    const confidence = calculateFieldConfidence(field, profileKey);
    if (confidence > 0) {
      matches.push({ profileKey, confidence });
    }
  }

  if (matches.length === 0) return null;

  // Return highest confidence match
  matches.sort((a, b) => b.confidence - a.confidence);
  return matches[0];
}

/**
 * Calculate overall form confidence
 * Average confidence of all mapped fields
 */
export function calculateOverallConfidence(mappings: Array<{ confidence: number }>): number {
  if (mappings.length === 0) return 0;

  const sum = mappings.reduce((acc, m) => acc + m.confidence, 0);
  return Math.round(sum / mappings.length);
}
```

**Commit:** `feat(02-03): create confidence scorer with fuse.js`
  </action>
</task>

<task type="auto">
  <name>Task 5: Create Field Detector</name>
  <files>src/lib/autofill/field-detector.ts</files>
  <action>
Create `src/lib/autofill/field-detector.ts` for field type detection:

```typescript
import type { DetectedField, FieldType } from '@/types/autofill';
import { querySelectorDeep } from '@/lib/ats/shadow-dom-utils';

/**
 * Detect all form fields on the page
 * Searches through Shadow DOM for Workday
 */
export function detectFormFields(
  container: HTMLElement | Document = document
): DetectedField[] {
  const fields: DetectedField[] = [];

  // Find all input, select, and textarea elements (including Shadow DOM)
  const inputElements = querySelectorDeep(
    'input:not([type="hidden"]):not([type="submit"]):not([type="button"]), select, textarea',
    container
  );

  for (const element of inputElements) {
    if (
      element instanceof HTMLInputElement ||
      element instanceof HTMLSelectElement ||
      element instanceof HTMLTextAreaElement
    ) {
      const field = createDetectedField(element);
      if (field) {
        fields.push(field);
      }
    }
  }

  return fields;
}

/**
 * Create DetectedField from form element
 */
function createDetectedField(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
): DetectedField | null {
  // Skip invisible fields
  if (!isVisible(element)) return null;

  const label = findFieldLabel(element);
  const type = detectFieldType(element);

  return {
    element,
    type,
    label,
    placeholder: element.getAttribute('placeholder'),
    name: element.getAttribute('name'),
    id: element.id || null,
    ariaLabel: element.getAttribute('aria-label'),
    required: element.required || element.getAttribute('aria-required') === 'true',
    currentValue: 'value' in element ? element.value : '',
  };
}

/**
 * Detect field type from element
 */
export function detectFieldType(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
): FieldType {
  if (element instanceof HTMLSelectElement) {
    return 'select';
  }

  if (element instanceof HTMLTextAreaElement) {
    return 'textarea';
  }

  if (element instanceof HTMLInputElement) {
    const type = element.type.toLowerCase();

    switch (type) {
      case 'email':
        return 'email';
      case 'tel':
        return 'phone';
      case 'url':
        return 'url';
      case 'date':
        return 'date';
      case 'checkbox':
        return 'checkbox';
      case 'radio':
        return 'radio';
      case 'file':
        return 'file';
      case 'text':
      case 'search':
      default:
        // Infer type from name/id/label
        return inferFieldType(element);
    }
  }

  return 'unknown';
}

/**
 * Infer field type from element attributes
 */
function inferFieldType(element: HTMLInputElement): FieldType {
  const name = element.name?.toLowerCase() || '';
  const id = element.id?.toLowerCase() || '';
  const label = findFieldLabel(element)?.toLowerCase() || '';
  const combined = `${name} ${id} ${label}`;

  if (/email/.test(combined)) return 'email';
  if (/phone|tel|mobile|cell/.test(combined)) return 'phone';
  if (/url|link|website/.test(combined)) return 'url';
  if (/date|year/.test(combined)) return 'date';

  return 'text';
}

/**
 * Find label for form element
 * Checks <label>, aria-label, aria-labelledby, and parent text
 */
function findFieldLabel(
  element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
): string | null {
  // Try <label> element
  if (element.id) {
    const label = document.querySelector(`label[for="${element.id}"]`);
    if (label?.textContent) {
      return label.textContent.trim();
    }
  }

  // Try parent label
  const parentLabel = element.closest('label');
  if (parentLabel?.textContent) {
    return parentLabel.textContent.trim();
  }

  // Try aria-labelledby
  const ariaLabelledBy = element.getAttribute('aria-labelledby');
  if (ariaLabelledBy) {
    const labelElement = document.getElementById(ariaLabelledBy);
    if (labelElement?.textContent) {
      return labelElement.textContent.trim();
    }
  }

  // Try aria-label
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel) {
    return ariaLabel.trim();
  }

  // Try placeholder as last resort
  const placeholder = element.getAttribute('placeholder');
  if (placeholder) {
    return placeholder.trim();
  }

  return null;
}

/**
 * Check if element is visible
 */
function isVisible(element: HTMLElement): boolean {
  // Check CSS visibility
  const style = window.getComputedStyle(element);
  if (
    style.display === 'none' ||
    style.visibility === 'hidden' ||
    style.opacity === '0'
  ) {
    return false;
  }

  // Check dimensions
  const rect = element.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) {
    return false;
  }

  return true;
}
```

**Commit:** `feat(02-03): create field detector with type inference`
  </action>
</task>

<task type="auto">
  <name>Task 6: Create Field Mapper</name>
  <files>src/lib/autofill/field-mapper.ts</files>
  <action>
Create `src/lib/autofill/field-mapper.ts` as the main field mapping orchestrator:

```typescript
import type { Profile } from '@/types/profile';
import type { DetectedField, FieldMapping, FormMappingResult } from '@/types/autofill';
import { detectFormFields } from './field-detector';
import { findBestMatch, calculateOverallConfidence } from './confidence-scorer';
import { CONFIDENCE_THRESHOLDS } from '@/constants/field-selectors';

/**
 * Map form fields to profile data
 * Returns field mappings with confidence scores
 *
 * @param profile - User profile data
 * @param container - Form container (defaults to document)
 * @returns Form mapping result with all field mappings
 */
export function mapFieldsToProfile(
  profile: Profile,
  container: HTMLElement | Document = document
): FormMappingResult {
  // Detect all form fields
  const fields = detectFormFields(container);

  // Map each field to profile data
  const mappings: FieldMapping[] = fields.map((field) => {
    return mapSingleField(field, profile);
  });

  // Calculate overall confidence
  const overallConfidence = calculateOverallConfidence(mappings);

  // Count fillable vs manual review fields
  const fillableCount = mappings.filter((m) => m.shouldFill).length;
  const manualReviewCount = mappings.filter(
    (m) => !m.shouldFill && m.confidence >= CONFIDENCE_THRESHOLDS.LOW
  ).length;

  return {
    fields,
    mappings,
    overallConfidence,
    fillableCount,
    manualReviewCount,
  };
}

/**
 * Map a single field to profile data
 */
function mapSingleField(field: DetectedField, profile: Profile): FieldMapping {
  // Find best matching profile field
  const match = findBestMatch(field);

  if (!match) {
    return {
      field,
      profileKey: null,
      value: null,
      confidence: 0,
      shouldFill: false,
      reason: 'No matching profile field found',
    };
  }

  const { profileKey, confidence } = match;

  // Get value from profile
  const value = getProfileValue(profile, profileKey);

  // Determine if field should be auto-filled
  const shouldFill =
    confidence >= CONFIDENCE_THRESHOLDS.MEDIUM &&
    value !== null &&
    value !== undefined &&
    value !== '';

  // Reason for low confidence
  let reason: string | undefined;
  if (confidence < CONFIDENCE_THRESHOLDS.MEDIUM) {
    reason = `Low confidence (${confidence}%) - requires manual review`;
  } else if (!value) {
    reason = 'No value in profile for this field';
  }

  return {
    field,
    profileKey,
    value: value?.toString() ?? null,
    confidence,
    shouldFill,
    reason,
  };
}

/**
 * Get value from profile by key
 * Handles nested objects and arrays
 */
function getProfileValue(profile: Profile, key: keyof Profile): string | null {
  const value = profile[key];

  if (value === null || value === undefined) return null;

  // Handle arrays (e.g., workHistory, education, skills)
  if (Array.isArray(value)) {
    return formatArrayValue(key, value);
  }

  // Handle objects
  if (typeof value === 'object') {
    return JSON.stringify(value);
  }

  return String(value);
}

/**
 * Format array values for form fields
 */
function formatArrayValue(key: keyof Profile, value: any[]): string | null {
  if (value.length === 0) return null;

  // Special formatting for specific fields
  switch (key) {
    case 'workHistory':
      // Format work history as "Company | Title | Years"
      return value
        .map((job) => `${job.company} | ${job.title} | ${job.startDate}-${job.endDate}`)
        .join('\n');

    case 'education':
      // Format education as "Degree, Major - University (Year)"
      return value
        .map((edu) => `${edu.degree}, ${edu.major} - ${edu.university} (${edu.graduationYear})`)
        .join('\n');

    case 'skills':
      // Format skills as comma-separated list
      return value.join(', ');

    default:
      return value.join(', ');
  }
}

/**
 * Get mapping by profile key
 */
export function getMappingByProfileKey(
  mappings: FieldMapping[],
  profileKey: keyof Profile
): FieldMapping | undefined {
  return mappings.find((m) => m.profileKey === profileKey);
}

/**
 * Get all high-confidence mappings (≥80%)
 */
export function getHighConfidenceMappings(mappings: FieldMapping[]): FieldMapping[] {
  return mappings.filter((m) => m.confidence >= CONFIDENCE_THRESHOLDS.HIGH);
}

/**
 * Get all mappings requiring manual review (50-69%)
 */
export function getManualReviewMappings(mappings: FieldMapping[]): FieldMapping[] {
  return mappings.filter(
    (m) =>
      m.confidence >= CONFIDENCE_THRESHOLDS.LOW && m.confidence < CONFIDENCE_THRESHOLDS.MEDIUM
  );
}
```

**Commit:** `feat(02-03): create field mapper orchestrator`
  </action>
</task>

<task type="auto">
  <name>Task 7: Create Field Mapper Unit Tests</name>
  <files>tests/unit/autofill/field-mapper.test.ts</files>
  <action>
Create comprehensive tests for field mapping accuracy:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { mapFieldsToProfile, getMappingByProfileKey } from '@/lib/autofill/field-mapper';
import { calculateFieldConfidence } from '@/lib/autofill/confidence-scorer';
import type { Profile } from '@/types/profile';
import type { DetectedField } from '@/types/autofill';

describe('Field Mapper', () => {
  let mockProfile: Profile;

  beforeEach(() => {
    mockProfile = {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
      phone: '555-1234',
      linkedinUrl: 'https://linkedin.com/in/johndoe',
      githubUrl: 'https://github.com/johndoe',
      currentCompany: 'Acme Corp',
      currentTitle: 'Software Engineer',
      skills: ['JavaScript', 'TypeScript', 'React'],
      // ... other fields
    } as Profile;
  });

  describe('Confidence Scoring', () => {
    it('should give high confidence for exact label match', () => {
      const field: DetectedField = {
        element: document.createElement('input'),
        type: 'email',
        label: 'Email Address',
        placeholder: null,
        name: null,
        id: null,
        ariaLabel: null,
        required: true,
        currentValue: '',
      };

      const confidence = calculateFieldConfidence(field, 'email');
      expect(confidence).toBeGreaterThanOrEqual(80);
    });

    it('should give medium confidence for fuzzy match', () => {
      const field: DetectedField = {
        element: document.createElement('input'),
        type: 'text',
        label: 'Your Email',
        placeholder: null,
        name: null,
        id: null,
        ariaLabel: null,
        required: false,
        currentValue: '',
      };

      const confidence = calculateFieldConfidence(field, 'email');
      expect(confidence).toBeGreaterThanOrEqual(60);
    });

    it('should give low confidence for poor match', () => {
      const field: DetectedField = {
        element: document.createElement('input'),
        type: 'text',
        label: 'Random Field',
        placeholder: null,
        name: null,
        id: null,
        ariaLabel: null,
        required: false,
        currentValue: '',
      };

      const confidence = calculateFieldConfidence(field, 'email');
      expect(confidence).toBeLessThan(50);
    });
  });

  describe('Field Mapping', () => {
    it('should map email field correctly', () => {
      // Create mock input
      const input = document.createElement('input');
      input.type = 'email';
      input.name = 'email';
      input.id = 'email-input';

      const label = document.createElement('label');
      label.htmlFor = 'email-input';
      label.textContent = 'Email Address';

      document.body.appendChild(label);
      document.body.appendChild(input);

      const result = mapFieldsToProfile(mockProfile);

      const emailMapping = getMappingByProfileKey(result.mappings, 'email');
      expect(emailMapping).toBeDefined();
      expect(emailMapping?.value).toBe('john@example.com');
      expect(emailMapping?.confidence).toBeGreaterThanOrEqual(80);
      expect(emailMapping?.shouldFill).toBe(true);

      // Cleanup
      document.body.removeChild(label);
      document.body.removeChild(input);
    });

    it('should achieve ≥85% accuracy on standard fields', () => {
      // Create standard application form
      const form = createStandardForm();
      document.body.appendChild(form);

      const result = mapFieldsToProfile(mockProfile, form);

      // Count correct mappings
      const standardFields: (keyof Profile)[] = [
        'firstName',
        'lastName',
        'email',
        'phone',
        'linkedinUrl',
        'currentCompany',
        'currentTitle',
      ];

      const correctMappings = standardFields.filter((key) => {
        const mapping = getMappingByProfileKey(result.mappings, key);
        return mapping && mapping.confidence >= 70;
      });

      const accuracy = (correctMappings.length / standardFields.length) * 100;
      expect(accuracy).toBeGreaterThanOrEqual(85);

      // Cleanup
      document.body.removeChild(form);
    });
  });
});

/**
 * Create a standard application form for testing
 */
function createStandardForm(): HTMLFormElement {
  const form = document.createElement('form');

  const fields = [
    { name: 'firstName', label: 'First Name', type: 'text' },
    { name: 'lastName', label: 'Last Name', type: 'text' },
    { name: 'email', label: 'Email Address', type: 'email' },
    { name: 'phone', label: 'Phone Number', type: 'tel' },
    { name: 'linkedin', label: 'LinkedIn Profile', type: 'url' },
    { name: 'company', label: 'Current Company', type: 'text' },
    { name: 'title', label: 'Current Job Title', type: 'text' },
  ];

  for (const field of fields) {
    const label = document.createElement('label');
    label.htmlFor = field.name;
    label.textContent = field.label;

    const input = document.createElement('input');
    input.type = field.type;
    input.name = field.name;
    input.id = field.name;

    form.appendChild(label);
    form.appendChild(input);
  }

  return form;
}
```

**Commit:** `feat(02-03): create field mapper unit tests`
  </action>
</task>

</tasks>

<verification>
- [ ] Fuse.js installed and imported correctly
- [ ] Field mapper achieves ≥85% accuracy on standard fields (run tests)
- [ ] Confidence scorer returns scores 0-100
- [ ] Field detector finds all visible form fields
- [ ] Shadow DOM fields detected (test with mock Workday structure)
- [ ] Low-confidence fields (<70%) flagged with reason
- [ ] High-confidence fields (≥80%) marked for auto-fill
- [ ] TypeScript compiles without errors
- [ ] Unit tests pass with ≥85% accuracy
</verification>

<success_criteria>
- ✅ Field mapping achieves ≥85% accuracy on standard form fields
- ✅ Fuzzy matching works with Fuse.js (threshold 0.4)
- ✅ Multi-strategy detection (label > ariaLabel > placeholder > name > id)
- ✅ Confidence scoring with weighted strategies
- ✅ Profile-to-form value mapping handles arrays and objects
- ✅ Low-confidence fields flagged for manual review
- ✅ Unit tests validate accuracy requirement
</success_criteria>

<next_steps>
After completing this plan:
1. Run unit tests to verify ≥85% accuracy
2. Test on mock Workday/Greenhouse/Lever forms
3. Adjust fuzzy matching threshold if needed
4. Move to Plan 02-04: Autofill Engine & Field Filling
</next_steps>

---

*Plan: 02-03-Field-Mapping-Engine*
*Priority: P0*
*Duration: 75 minutes*
