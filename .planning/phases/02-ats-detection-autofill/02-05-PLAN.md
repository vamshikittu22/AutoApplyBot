---
phase: 02-ats-detection-autofill
plan: 05
type: execute
wave: 5
depends_on: ['02-04']
files_modified:
  - src/entrypoints/content/autofill-button.content/index.tsx
  - src/entrypoints/content/autofill-button.content/AutofillButton.tsx
  - src/entrypoints/content/autofill-button.content/style.css
  - src/lib/ui/button-positioner.ts
  - src/lib/ui/field-decorator.ts
  - src/components/FieldIndicator.tsx
autonomous: true

must_haves:
  truths:
    - "Autofill button appears when ATS form detected"
    - "Button uses hybrid positioning (inline → fixed on scroll)"
    - "Visual field highlighting (green/yellow/red borders + icons)"
    - "Per-field undo buttons visible after fill"
  artifacts:
    - path: "src/entrypoints/content/autofill-button.content/index.tsx"
      provides: "Content script for autofill button UI"
      exports: []
      min_lines: 100
    - path: "src/entrypoints/content/autofill-button.content/AutofillButton.tsx"
      provides: "Autofill button component with state management"
      exports: ["AutofillButton"]
      min_lines: 200
    - path: "src/entrypoints/content/autofill-button.content/style.css"
      provides: "Shadow DOM styles for button and indicators"
      exports: []
      min_lines: 100
    - path: "src/lib/ui/button-positioner.ts"
      provides: "Hybrid positioning logic (inline → fixed on scroll)"
      exports: ["ButtonPositioner"]
      min_lines: 120
    - path: "src/lib/ui/field-decorator.ts"
      provides: "Visual field highlighting system"
      exports: ["decorateField", "clearDecoration"]
      min_lines: 100
    - path: "src/components/FieldIndicator.tsx"
      provides: "Confidence indicator component"
      exports: ["FieldIndicator"]
      min_lines: 80
  key_links:
    - from: "src/entrypoints/content/autofill-button.content/AutofillButton.tsx"
      to: "@/lib/autofill/engine"
      via: "Uses AutofillEngine"
      pattern: "AutofillEngine"
    - from: "src/lib/ui/field-decorator.ts"
      to: "@/types/autofill"
      via: "Decorates FieldMapping results"
      pattern: "FieldMapping"
---

<objective>
Build autofill button UI with hybrid positioning and visual field highlighting system.

**Purpose:** Create user-facing autofill button that appears when ATS forms detected, uses hybrid positioning (inline → fixed on scroll), and provides visual feedback (green/yellow/red field borders, confidence indicators, per-field undo) (REQ-ATS-13, REQ-ATS-14, REQ-ATS-15, REQ-ATS-16).

**Output:** Fully functional autofill button UI with Shadow DOM isolation, visual field highlighting, and responsive positioning.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-ats-detection-autofill/02-00-OVERVIEW.md
@.planning/phases/02-ats-detection-autofill/02-01-PLAN.md
@.planning/phases/02-ats-detection-autofill/02-02-PLAN.md
@.planning/phases/02-ats-detection-autofill/02-03-PLAN.md
@.planning/phases/02-ats-detection-autofill/02-04-PLAN.md
@TECHSTACK.md
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Field Indicator Component</name>
  <files>src/components/FieldIndicator.tsx</files>
  <action>
Create `src/components/FieldIndicator.tsx` for confidence visualization:

```typescript
import React from 'react';

export interface FieldIndicatorProps {
  /** Confidence level (0-100) */
  confidence: number;
  /** Is field filled? */
  filled: boolean;
  /** Show numeric confidence? */
  showConfidence?: boolean;
  /** Size variant */
  size?: 'sm' | 'md' | 'lg';
}

/**
 * Visual indicator for field confidence and fill status
 * Green = high confidence, filled
 * Yellow = medium confidence
 * Red = low confidence
 * Gray = not filled
 */
export function FieldIndicator({
  confidence,
  filled,
  showConfidence = false,
  size = 'md',
}: FieldIndicatorProps) {
  const getColor = () => {
    if (!filled) return 'gray';
    if (confidence >= 80) return 'green';
    if (confidence >= 70) return 'yellow';
    return 'red';
  };

  const getIcon = () => {
    if (!filled) return '○';
    if (confidence >= 80) return '✓';
    if (confidence >= 70) return '!';
    return '?';
  };

  const color = getColor();
  const icon = getIcon();

  const sizeClasses = {
    sm: 'w-4 h-4 text-xs',
    md: 'w-6 h-6 text-sm',
    lg: 'w-8 h-8 text-base',
  };

  const colorClasses = {
    green: 'bg-green-100 text-green-700 border-green-300',
    yellow: 'bg-yellow-100 text-yellow-700 border-yellow-300',
    red: 'bg-red-100 text-red-700 border-red-300',
    gray: 'bg-gray-100 text-gray-500 border-gray-300',
  };

  return (
    <div
      className={`
        inline-flex items-center justify-center
        rounded-full border
        font-semibold
        ${sizeClasses[size]}
        ${colorClasses[color]}
      `}
      title={`Confidence: ${confidence}%`}
    >
      {showConfidence ? confidence : icon}
    </div>
  );
}
```

**Commit:** `feat(02-05): create field indicator component`
  </action>
</task>

<task type="auto">
  <name>Task 2: Create Field Decorator</name>
  <files>src/lib/ui/field-decorator.ts</files>
  <action>
Create `src/lib/ui/field-decorator.ts` for visual field highlighting:

**Implementation approach:**
- Add colored borders to fields based on confidence
- Create overlay badges for confidence indicators
- Add inline undo buttons
- Handle Z-index and positioning edge cases

```typescript
import type { FieldMapping } from '@/types/autofill';

/**
 * Field decoration data
 */
interface FieldDecoration {
  element: HTMLElement;
  indicator: HTMLElement;
  undoButton: HTMLElement | null;
  originalBorder: string;
  originalOutline: string;
}

/**
 * Store of decorated fields
 */
const decoratedFields = new Map<HTMLElement, FieldDecoration>();

/**
 * Decorate a filled field with visual indicators
 * Green border = high confidence (≥80%)
 * Yellow border = medium confidence (70-79%)
 * Red border = low confidence (<70%)
 */
export function decorateField(mapping: FieldMapping, onUndo?: () => void): void {
  const { field, confidence, shouldFill } = mapping;
  const element = field.element;

  // Don't decorate if already decorated
  if (decoratedFields.has(element)) {
    return;
  }

  // Store original styles
  const originalBorder = element.style.border;
  const originalOutline = element.style.outline;

  // Determine color based on confidence
  const color = getConfidenceColor(confidence);
  const borderColor = COLOR_MAP[color];

  // Apply border
  element.style.border = `2px solid ${borderColor}`;
  element.style.outline = 'none';
  element.style.transition = 'border-color 0.3s ease';

  // Create confidence indicator badge
  const indicator = createIndicatorBadge(confidence, color);
  positionIndicator(element, indicator);

  // Create undo button if filled
  let undoButton: HTMLElement | null = null;
  if (shouldFill && onUndo) {
    undoButton = createUndoButton(onUndo);
    positionUndoButton(element, undoButton);
  }

  // Store decoration data
  decoratedFields.set(element, {
    element,
    indicator,
    undoButton,
    originalBorder,
    originalOutline,
  });

  // Add to DOM
  document.body.appendChild(indicator);
  if (undoButton) {
    document.body.appendChild(undoButton);
  }

  // Update position on scroll/resize
  const updatePosition = () => {
    positionIndicator(element, indicator);
    if (undoButton) {
      positionUndoButton(element, undoButton);
    }
  };

  window.addEventListener('scroll', updatePosition, { passive: true });
  window.addEventListener('resize', updatePosition, { passive: true });
}

/**
 * Clear decoration from a field
 */
export function clearDecoration(element: HTMLElement): void {
  const decoration = decoratedFields.get(element);
  if (!decoration) return;

  // Restore original styles
  element.style.border = decoration.originalBorder;
  element.style.outline = decoration.originalOutline;

  // Remove indicator and undo button
  decoration.indicator.remove();
  decoration.undoButton?.remove();

  decoratedFields.delete(element);
}

/**
 * Clear all decorations
 */
export function clearAllDecorations(): void {
  for (const [element] of decoratedFields) {
    clearDecoration(element);
  }
}

/**
 * Get confidence color category
 */
function getConfidenceColor(confidence: number): 'green' | 'yellow' | 'red' {
  if (confidence >= 80) return 'green';
  if (confidence >= 70) return 'yellow';
  return 'red';
}

const COLOR_MAP = {
  green: '#10b981',
  yellow: '#f59e0b',
  red: '#ef4444',
};

/**
 * Create confidence indicator badge
 */
function createIndicatorBadge(confidence: number, color: 'green' | 'yellow' | 'red'): HTMLElement {
  const badge = document.createElement('div');
  badge.className = 'autoapply-field-indicator';
  badge.style.cssText = `
    position: absolute;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: ${COLOR_MAP[color]};
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    z-index: 10000;
    pointer-events: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  `;

  const icon = confidence >= 80 ? '✓' : confidence >= 70 ? '!' : '?';
  badge.textContent = icon;
  badge.title = `Confidence: ${confidence}%`;

  return badge;
}

/**
 * Create undo button
 */
function createUndoButton(onUndo: () => void): HTMLElement {
  const button = document.createElement('button');
  button.className = 'autoapply-undo-button';
  button.textContent = '↶';
  button.title = 'Undo';
  button.style.cssText = `
    position: absolute;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    background: #6366f1;
    color: white;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    cursor: pointer;
    z-index: 10001;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: background 0.2s;
  `;

  button.addEventListener('mouseenter', () => {
    button.style.background = '#4f46e5';
  });

  button.addEventListener('mouseleave', () => {
    button.style.background = '#6366f1';
  });

  button.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    onUndo();
  });

  return button;
}

/**
 * Position indicator badge relative to field
 */
function positionIndicator(field: HTMLElement, indicator: HTMLElement): void {
  const rect = field.getBoundingClientRect();
  indicator.style.top = `${rect.top + window.scrollY - 10}px`;
  indicator.style.left = `${rect.left + window.scrollX - 10}px`;
}

/**
 * Position undo button relative to field
 */
function positionUndoButton(field: HTMLElement, button: HTMLElement): void {
  const rect = field.getBoundingClientRect();
  button.style.top = `${rect.top + window.scrollY - 10}px`;
  button.style.left = `${rect.right + window.scrollX - 14}px`;
}

/**
 * Get all decorated fields
 */
export function getDecoratedFields(): HTMLElement[] {
  return Array.from(decoratedFields.keys());
}
```

**Commit:** `feat(02-05): create field decorator for visual highlighting`
  </action>
</task>

<task type="auto">
  <name>Task 3: Create Button Positioner</name>
  <files>src/lib/ui/button-positioner.ts</files>
  <action>
Create `src/lib/ui/button-positioner.ts` for hybrid button positioning:

**Implementation approach:**
- Start with inline positioning (above form)
- Switch to fixed positioning when button scrolls out of view
- Handle edge cases (viewport boundaries, form relocation)

```typescript
/**
 * Button position mode
 */
export type PositionMode = 'inline' | 'fixed';

/**
 * Position configuration
 */
export interface PositionConfig {
  mode: PositionMode;
  top?: number;
  left?: number;
  right?: number;
  bottom?: number;
}

/**
 * Hybrid button positioner
 * Starts inline, switches to fixed on scroll
 */
export class ButtonPositioner {
  private buttonElement: HTMLElement;
  private formContainer: HTMLElement;
  private mode: PositionMode = 'inline';
  private inlinePosition: DOMRect | null = null;
  private onModeChange?: (mode: PositionMode) => void;

  constructor(
    buttonElement: HTMLElement,
    formContainer: HTMLElement,
    onModeChange?: (mode: PositionMode) => void
  ) {
    this.buttonElement = buttonElement;
    this.formContainer = formContainer;
    this.onModeChange = onModeChange;

    this.init();
  }

  /**
   * Initialize positioning
   */
  private init(): void {
    // Start in inline mode
    this.setInlineMode();

    // Store initial position
    this.inlinePosition = this.buttonElement.getBoundingClientRect();

    // Listen for scroll/resize
    window.addEventListener('scroll', this.handleScroll, { passive: true });
    window.addEventListener('resize', this.handleResize, { passive: true });
  }

  /**
   * Handle scroll event
   */
  private handleScroll = (): void => {
    if (!this.inlinePosition) return;

    const formRect = this.formContainer.getBoundingClientRect();
    const viewportHeight = window.innerHeight;

    // Switch to fixed if form is scrolled out of top viewport
    if (formRect.top < 0 && formRect.bottom > 100) {
      if (this.mode !== 'fixed') {
        this.setFixedMode();
      }
    } else {
      // Switch back to inline when form in view
      if (this.mode !== 'inline') {
        this.setInlineMode();
      }
    }
  };

  /**
   * Handle resize event
   */
  private handleResize = (): void => {
    // Update inline position
    if (this.mode === 'inline') {
      this.inlinePosition = this.buttonElement.getBoundingClientRect();
    }
  };

  /**
   * Set inline mode
   */
  private setInlineMode(): void {
    this.buttonElement.style.position = 'static';
    this.buttonElement.style.top = '';
    this.buttonElement.style.left = '';
    this.buttonElement.style.right = '';
    this.buttonElement.style.bottom = '';

    this.mode = 'inline';
    this.onModeChange?.('inline');
  }

  /**
   * Set fixed mode (top-right corner)
   */
  private setFixedMode(): void {
    this.buttonElement.style.position = 'fixed';
    this.buttonElement.style.top = '16px';
    this.buttonElement.style.right = '16px';
    this.buttonElement.style.left = '';
    this.buttonElement.style.bottom = '';
    this.buttonElement.style.zIndex = '10000';

    this.mode = 'fixed';
    this.onModeChange?.('fixed');
  }

  /**
   * Get current mode
   */
  getMode(): PositionMode {
    return this.mode;
  }

  /**
   * Cleanup
   */
  destroy(): void {
    window.removeEventListener('scroll', this.handleScroll);
    window.removeEventListener('resize', this.handleResize);
  }
}
```

**Commit:** `feat(02-05): create button positioner for hybrid positioning`
  </action>
</task>

<task type="auto">
  <name>Task 4: Create Autofill Button Component</name>
  <files>src/entrypoints/content/autofill-button.content/AutofillButton.tsx</files>
  <action>
Create `src/entrypoints/content/autofill-button.content/AutofillButton.tsx`:

```typescript
import React, { useState, useEffect } from 'react';
import { AutofillEngine } from '@/lib/autofill/engine';
import { decorateField, clearAllDecorations } from '@/lib/ui/field-decorator';
import type { Profile } from '@/types/profile';
import type { ATSType } from '@/types/ats';
import { FieldIndicator } from '@/components/FieldIndicator';

export interface AutofillButtonProps {
  profile: Profile;
  atsType: ATSType;
  formContainer: HTMLElement;
}

type ButtonState = 'idle' | 'loading' | 'filling' | 'success' | 'error';

export function AutofillButton({ profile, atsType, formContainer }: AutofillButtonProps) {
  const [state, setState] = useState<ButtonState>('idle');
  const [progress, setProgress] = useState({ current: 0, total: 0 });
  const [filledCount, setFilledCount] = useState(0);
  const [engine] = useState(() => new AutofillEngine());

  useEffect(() => {
    engine.setProfile(profile);
    engine.setATSType(atsType);
  }, [profile, atsType, engine]);

  const handleAutofill = async () => {
    setState('filling');
    clearAllDecorations();

    try {
      const result = await engine.autofill({
        container: formContainer,
        onProgress: (current, total, fieldName) => {
          setProgress({ current, total });
        },
        onFieldFilled: (mapping) => {
          // Decorate filled field
          decorateField(mapping, () => {
            engine.undoField(mapping.field.element);
            clearDecoration(mapping.field.element);
          });
        },
      });

      setFilledCount(result.filledCount);
      setState('success');

      // Auto-hide success state after 3 seconds
      setTimeout(() => {
        if (result.filledCount > 0) {
          setState('idle');
        }
      }, 3000);
    } catch (error) {
      console.error('[AutofillButton] Error:', error);
      setState('error');

      setTimeout(() => {
        setState('idle');
      }, 3000);
    }
  };

  const handleUndoAll = () => {
    const count = engine.undoAll();
    clearAllDecorations();
    setFilledCount(0);
    setState('idle');
    console.log(`[AutofillButton] Undone ${count} fields`);
  };

  const getButtonText = () => {
    switch (state) {
      case 'loading':
        return 'Loading...';
      case 'filling':
        return `Filling ${progress.current}/${progress.total}...`;
      case 'success':
        return `✓ Filled ${filledCount} fields`;
      case 'error':
        return '✗ Error occurred';
      default:
        return 'Autofill Profile';
    }
  };

  const getButtonClass = () => {
    const baseClass = `
      px-4 py-2 rounded-lg font-semibold text-sm
      transition-all duration-200
      flex items-center gap-2
      shadow-lg hover:shadow-xl
    `;

    switch (state) {
      case 'success':
        return `${baseClass} bg-green-600 text-white`;
      case 'error':
        return `${baseClass} bg-red-600 text-white`;
      case 'filling':
        return `${baseClass} bg-blue-500 text-white cursor-wait`;
      default:
        return `${baseClass} bg-indigo-600 text-white hover:bg-indigo-700 cursor-pointer`;
    }
  };

  const canUndo = engine.getUndoCount() > 0;

  return (
    <div className="flex flex-col gap-2 items-start">
      <div className="flex gap-2">
        <button
          onClick={handleAutofill}
          disabled={state === 'filling'}
          className={getButtonClass()}
        >
          {state === 'filling' && (
            <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
                fill="none"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
          )}
          <span>{getButtonText()}</span>
        </button>

        {canUndo && state !== 'filling' && (
          <button
            onClick={handleUndoAll}
            className="px-4 py-2 rounded-lg font-semibold text-sm bg-gray-600 text-white hover:bg-gray-700 shadow-lg hover:shadow-xl transition-all duration-200"
          >
            Undo All ({engine.getUndoCount()})
          </button>
        )}
      </div>

      {state === 'success' && (
        <div className="text-sm text-green-700 bg-green-50 px-3 py-2 rounded border border-green-200">
          ✓ Review the highlighted fields and edit as needed
        </div>
      )}

      {state === 'error' && (
        <div className="text-sm text-red-700 bg-red-50 px-3 py-2 rounded border border-red-200">
          ✗ Some fields could not be filled. Try manual mode.
        </div>
      )}
    </div>
  );
}
```

**Commit:** `feat(02-05): create autofill button component`
  </action>
</task>

<task type="auto">
  <name>Task 5: Create Autofill Button Content Script</name>
  <files>src/entrypoints/content/autofill-button.content/index.tsx</files>
  <action>
Create `src/entrypoints/content/autofill-button.content/index.tsx`:

```typescript
import { defineContentScript } from 'wxt/sandbox';
import ReactDOM from 'react-dom/client';
import React from 'react';
import { AutofillButton } from './AutofillButton';
import { ButtonPositioner } from '@/lib/ui/button-positioner';
import { findFormContainers } from '@/lib/ats/detector';
import type { Profile } from '@/types/profile';
import type { ATSType, DetectionResult } from '@/types/ats';
import './style.css';

export default defineContentScript({
  matches: [
    '*://*/myworkdayjobs/*',
    '*://*/myworkday.com/*',
    '*://*.myworkdayjobs.com/*',
    '*://*.myworkday.com/*',
    '*://boards.greenhouse.io/*',
    '*://*.greenhouse.io/*',
    '*://*/embed/job_app*',
    '*://jobs.lever.co/*',
    '*://*.lever.co/*',
    '*://*/apply/*',
  ],

  main() {
    console.log('[Autofill Button] Content script loaded');

    let buttonContainer: HTMLElement | null = null;
    let positioner: ButtonPositioner | null = null;

    /**
     * Initialize autofill button
     */
    async function initButton(detection: DetectionResult) {
      if (!detection.platform || detection.confidence < 50) {
        console.log('[Autofill Button] Detection confidence too low, not showing button');
        return;
      }

      // Get user profile
      const { profile } = await chrome.storage.local.get('profile');
      if (!profile) {
        console.log('[Autofill Button] No profile found');
        return;
      }

      // Find form container
      const containers = findFormContainers(detection.platform, document);
      if (containers.length === 0) {
        console.log('[Autofill Button] No form containers found');
        return;
      }

      const formContainer = containers[0];

      // Create button container with Shadow DOM
      buttonContainer = document.createElement('div');
      buttonContainer.id = 'autoapply-button-root';
      buttonContainer.style.cssText = `
        margin-bottom: 16px;
        z-index: 10000;
      `;

      // Insert before form
      formContainer.parentElement?.insertBefore(buttonContainer, formContainer);

      // Attach Shadow DOM
      const shadowRoot = buttonContainer.attachShadow({ mode: 'open' });

      // Add Tailwind styles to Shadow DOM
      const style = document.createElement('style');
      style.textContent = `@import "${chrome.runtime.getURL('content-scripts/autofill-button.css')}";`;
      shadowRoot.appendChild(style);

      // Create React root in Shadow DOM
      const reactRoot = document.createElement('div');
      shadowRoot.appendChild(reactRoot);

      // Render button
      const root = ReactDOM.createRoot(reactRoot);
      root.render(
        <React.StrictMode>
          <AutofillButton
            profile={profile as Profile}
            atsType={detection.platform as ATSType}
            formContainer={formContainer}
          />
        </React.StrictMode>
      );

      // Set up hybrid positioning
      positioner = new ButtonPositioner(buttonContainer, formContainer, (mode) => {
        console.log('[Autofill Button] Position mode:', mode);
      });

      console.log('[Autofill Button] Button initialized');
    }

    /**
     * Cleanup button
     */
    function cleanup() {
      if (buttonContainer) {
        buttonContainer.remove();
        buttonContainer = null;
      }

      if (positioner) {
        positioner.destroy();
        positioner = null;
      }
    }

    // Listen for ATS detection events
    window.addEventListener('autoapply:ats-detected', ((event: CustomEvent) => {
      const detection = event.detail as DetectionResult;
      console.log('[Autofill Button] ATS detected:', detection);

      cleanup();
      initButton(detection);
    }) as EventListener);

    // Cleanup on unload
    window.addEventListener('beforeunload', cleanup);
  },
});
```

**Commit:** `feat(02-05): create autofill button content script`
  </action>
</task>

<task type="auto">
  <name>Task 6: Create Shadow DOM Styles</name>
  <files>src/entrypoints/content/autofill-button.content/style.css</files>
  <action>
Create `src/entrypoints/content/autofill-button.content/style.css`:

```css
/* Shadow DOM styles for autofill button */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Reset default styles */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Button base styles */
button {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

button:focus {
  outline: 2px solid #6366f1;
  outline-offset: 2px;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Animation keyframes */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-out;
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Fixed mode styles */
.fixed-mode {
  position: fixed !important;
  top: 16px !important;
  right: 16px !important;
  z-index: 10000 !important;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3) !important;
}

/* Confidence indicators */
.confidence-high {
  border-color: #10b981 !important;
}

.confidence-medium {
  border-color: #f59e0b !important;
}

.confidence-low {
  border-color: #ef4444 !important;
}
```

**Commit:** `feat(02-05): create shadow dom styles for autofill button`
  </action>
</task>

</tasks>

<verification>
- [ ] Autofill button appears when ATS form detected
- [ ] Button uses Shadow DOM (styles isolated)
- [ ] Hybrid positioning works (inline → fixed on scroll)
- [ ] Field highlighting visible (green/yellow/red borders)
- [ ] Confidence indicators show on filled fields
- [ ] Per-field undo buttons work
- [ ] Undo All button appears when fields filled
- [ ] Button disabled during filling
- [ ] Progress indicator shows during fill
- [ ] Success/error states display correctly
</verification>

<success_criteria>
- ✅ Autofill button UI component with React
- ✅ Hybrid positioning (inline → fixed on scroll)
- ✅ Shadow DOM isolation for styles
- ✅ Visual field highlighting (green/yellow/red)
- ✅ Confidence indicator badges
- ✅ Per-field undo buttons
- ✅ Undo All button
- ✅ Loading and progress states
- ✅ Success and error feedback
</success_criteria>

<next_steps>
After completing this plan:
1. Test button appearance on real ATS forms
2. Verify Shadow DOM style isolation
3. Test hybrid positioning on scroll
4. Verify field decorations visible
5. Move to Plan 02-06: Helper Mode & Graceful Degradation
</next_steps>

---

*Plan: 02-05-Autofill-Button-UI*
*Priority: P1*
*Duration: 75 minutes*
