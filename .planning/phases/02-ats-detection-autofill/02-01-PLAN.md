# Plan 02-01: ATS Detection Foundation

**Priority:** P0 (Must-have)
**Estimated Duration:** 60 minutes
**Dependencies:** Phase 0 (WXT setup), Phase 1 (Profile system)

---

## Objective

Build multi-signal ATS detection engine with ≥95% accuracy for Workday, Greenhouse, and Lever platforms. Implement platform-specific detection logic using URL patterns, DOM signatures, Shadow DOM markers, and data attributes.

---

## Requirements

**From PRD.md (Epic 2: ATS Detection & Autofill):**
- US2.1: ATS Recognition with ≥95% accuracy on 10+ URLs per platform
- Workday (priority 1), Greenhouse (priority 2), Lever (priority 3)
- Detection confidence scoring system
- Multi-signal detection to reduce false positives

**From 02-RESEARCH.md:**
- Pattern 1: Multi-Signal ATS Detection (URL + DOM + Shadow + attributes)
- Confidence weighting: URL (30%), DOM (40%), Attributes (20%), Shadow DOM (10%)
- Pitfall 4: False Positive ATS Detection — require ≥3 signals

**From 02-CONTEXT.md:**
- Multiple signals preferred to reduce false positives
- Uncertain detection (50-70% confidence) shows "maybe" indicator
- User can manually activate if they know it's an ATS form

---

## Tasks

### Task 1: Create ATS Type Definitions (15 min)

**Create:** `src/types/ats.ts`

```typescript
/**
 * Supported ATS platforms
 */
export type ATSType = 'workday' | 'greenhouse' | 'lever';

/**
 * Detection signal types
 */
export type DetectionSignal = 'url' | 'dom' | 'shadow' | 'attributes';

/**
 * Detection confidence levels
 */
export type ConfidenceLevel = 'high' | 'medium' | 'low' | 'none';

/**
 * Result of ATS detection
 */
export interface DetectionResult {
  /** Detected platform (null if no detection) */
  platform: ATSType | null;
  /** Confidence score 0-100 */
  confidence: number;
  /** Which signals contributed to detection */
  signals: DetectionSignal[];
  /** Confidence level category */
  level: ConfidenceLevel;
  /** Timestamp of detection */
  timestamp: number;
}

/**
 * Platform-specific detection configuration
 */
export interface ATSDetector {
  /** Platform name */
  platform: ATSType;
  /** Detect if this platform is present on the page */
  detect: (url: string, document: Document) => Promise<DetectionResult>;
  /** Get form container element(s) for this platform */
  findFormContainers: (document: Document) => HTMLElement[];
}
```

**Commit:** `feat(02-01): create ATS type definitions`

---

### Task 2: Create ATS URL Patterns & DOM Signatures (15 min)

**Create:** `src/constants/ats-patterns.ts`

```typescript
import type { ATSType } from '@/types/ats';

/**
 * URL patterns for ATS detection
 * Each pattern includes host, path, and query indicators
 */
export const ATS_URL_PATTERNS: Record<ATSType, {
  hosts: string[];
  paths: string[];
  queryParams?: string[];
}> = {
  workday: {
    hosts: ['myworkday.com', 'myworkdayjobs.com'],
    paths: ['/d/inst/', '/jobs/', '/apply/'],
    queryParams: ['source'],
  },
  greenhouse: {
    hosts: ['greenhouse.io', 'boards.greenhouse.io'],
    paths: ['/application', '/embed/job_app'],
  },
  lever: {
    hosts: ['lever.co', 'jobs.lever.co'],
    paths: ['/apply/', '/application/'],
  },
};

/**
 * DOM signatures for ATS detection
 * CSS selectors that uniquely identify each platform
 */
export const ATS_DOM_SIGNATURES: Record<ATSType, {
  containers: string[];
  markers: string[];
  negativeMarkers?: string[];
}> = {
  workday: {
    containers: [
      '[data-automation-id="applicationContainer"]',
      '[data-automation-id="jobRequisition"]',
      'wd-app-root',
    ],
    markers: [
      '[data-automation-id^="formField"]',
      '[data-automation-id="applyButton"]',
      'wd-text-input',
    ],
    negativeMarkers: ['[data-automation-id="searchResults"]'], // Not an application form
  },
  greenhouse: {
    containers: [
      '#application_form',
      '.application-form',
      '[data-qa="application-form"]',
    ],
    markers: [
      '[data-qa="job-application"]',
      '.greenhouse-form',
      '#submit_app',
    ],
  },
  lever: {
    containers: [
      '.application-form',
      '[data-qa="application-form"]',
      '.lever-application',
    ],
    markers: [
      '[data-qa="job-apply"]',
      '.lever-jobs-apply',
      'form.application',
    ],
  },
};

/**
 * Data attribute patterns for detection
 */
export const ATS_DATA_ATTRIBUTES: Record<ATSType, {
  attributes: string[];
  values?: Record<string, string | RegExp>;
}> = {
  workday: {
    attributes: ['data-automation-id', 'data-wd-app'],
    values: {
      'data-automation-id': /^(formField|apply|application)/,
    },
  },
  greenhouse: {
    attributes: ['data-qa', 'data-source'],
    values: {
      'data-qa': /^(job|application)/,
    },
  },
  lever: {
    attributes: ['data-qa', 'data-lever'],
    values: {
      'data-qa': /^(job|apply)/,
    },
  },
};

/**
 * Shadow DOM detection patterns (Workday-specific)
 */
export const SHADOW_DOM_MARKERS = {
  workday: [
    'wd-app-root',
    'wd-text-input',
    'wd-select',
    'wd-date-picker',
  ],
};

/**
 * Confidence score weights for each signal type
 */
export const DETECTION_WEIGHTS = {
  url: 30,
  dom: 40,
  attributes: 20,
  shadow: 10,
};

/**
 * Confidence thresholds for categorization
 */
export const CONFIDENCE_THRESHOLDS = {
  high: 80,    // ≥80% = high confidence, show full UI
  medium: 50,  // 50-79% = medium confidence, show "maybe" indicator
  low: 0,      // <50% = low confidence, no detection shown
};
```

**Commit:** `feat(02-01): create ATS URL patterns and DOM signatures`

---

### Task 3: Implement Platform-Specific Detectors (20 min)

**Create:** `src/lib/ats/workday.ts`

```typescript
import type { DetectionResult, ATSDetector } from '@/types/ats';
import {
  ATS_URL_PATTERNS,
  ATS_DOM_SIGNATURES,
  ATS_DATA_ATTRIBUTES,
  SHADOW_DOM_MARKERS,
  DETECTION_WEIGHTS,
  CONFIDENCE_THRESHOLDS,
} from '@/constants/ats-patterns';

/**
 * Workday ATS detector
 * Workday uses Shadow DOM extensively, so we need special handling
 */
export const workdayDetector: ATSDetector = {
  platform: 'workday',

  async detect(url: string, document: Document): Promise<DetectionResult> {
    let confidence = 0;
    const signals: DetectionResult['signals'] = [];

    // Signal 1: URL pattern matching (30% weight)
    if (checkWorkdayURL(url)) {
      confidence += DETECTION_WEIGHTS.url;
      signals.push('url');
    }

    // Signal 2: DOM signatures (40% weight)
    if (checkWorkdayDOM(document)) {
      confidence += DETECTION_WEIGHTS.dom;
      signals.push('dom');
    }

    // Signal 3: Data attributes (20% weight)
    if (checkWorkdayAttributes(document)) {
      confidence += DETECTION_WEIGHTS.attributes;
      signals.push('attributes');
    }

    // Signal 4: Shadow DOM markers (10% weight) - Workday specific
    if (await checkWorkdayShadowDOM(document)) {
      confidence += DETECTION_WEIGHTS.shadow;
      signals.push('shadow');
    }

    // Determine confidence level
    const level = getConfidenceLevel(confidence);

    return {
      platform: confidence >= CONFIDENCE_THRESHOLDS.medium ? 'workday' : null,
      confidence,
      signals,
      level,
      timestamp: Date.now(),
    };
  },

  findFormContainers(document: Document): HTMLElement[] {
    const containers: HTMLElement[] = [];
    const signatures = ATS_DOM_SIGNATURES.workday.containers;

    for (const selector of signatures) {
      const elements = document.querySelectorAll(selector);
      containers.push(...Array.from(elements) as HTMLElement[]);
    }

    // Check Shadow DOM for form containers
    const shadowContainers = findWorkdayFormsInShadowDOM(document);
    containers.push(...shadowContainers);

    return containers;
  },
};

function checkWorkdayURL(url: string): boolean {
  const patterns = ATS_URL_PATTERNS.workday;
  const urlObj = new URL(url);

  // Check host
  const hostMatch = patterns.hosts.some((host) =>
    urlObj.hostname.includes(host)
  );

  // Check path
  const pathMatch = patterns.paths.some((path) => urlObj.pathname.includes(path));

  return hostMatch && pathMatch;
}

function checkWorkdayDOM(document: Document): boolean {
  const signatures = ATS_DOM_SIGNATURES.workday;

  // Check for positive markers
  const hasContainers = signatures.containers.some((selector) =>
    document.querySelector(selector) !== null
  );

  const hasMarkers = signatures.markers.some((selector) =>
    document.querySelector(selector) !== null
  );

  // Check for negative markers (exclude false positives)
  const hasNegativeMarkers = signatures.negativeMarkers?.some((selector) =>
    document.querySelector(selector) !== null
  ) ?? false;

  return (hasContainers || hasMarkers) && !hasNegativeMarkers;
}

function checkWorkdayAttributes(document: Document): boolean {
  const patterns = ATS_DATA_ATTRIBUTES.workday;

  for (const attr of patterns.attributes) {
    const elements = document.querySelectorAll(`[${attr}]`);

    for (const element of elements) {
      const value = element.getAttribute(attr);
      if (value && patterns.values) {
        const expectedValue = patterns.values[attr];
        if (expectedValue instanceof RegExp && expectedValue.test(value)) {
          return true;
        }
        if (typeof expectedValue === 'string' && value.includes(expectedValue)) {
          return true;
        }
      }
    }
  }

  return false;
}

async function checkWorkdayShadowDOM(document: Document): Promise<boolean> {
  const markers = SHADOW_DOM_MARKERS.workday;

  // Check if any shadow DOM hosts with Workday markers exist
  for (const marker of markers) {
    const element = document.querySelector(marker);
    if (element?.shadowRoot) {
      return true;
    }
  }

  return false;
}

function findWorkdayFormsInShadowDOM(document: Document): HTMLElement[] {
  const forms: HTMLElement[] = [];
  const markers = SHADOW_DOM_MARKERS.workday;

  for (const marker of markers) {
    const hosts = document.querySelectorAll(marker);
    hosts.forEach((host) => {
      if (host.shadowRoot) {
        const shadowForms = host.shadowRoot.querySelectorAll('form, [role="form"]');
        forms.push(...Array.from(shadowForms) as HTMLElement[]);
      }
    });
  }

  return forms;
}

function getConfidenceLevel(confidence: number): DetectionResult['level'] {
  if (confidence >= CONFIDENCE_THRESHOLDS.high) return 'high';
  if (confidence >= CONFIDENCE_THRESHOLDS.medium) return 'medium';
  return 'low';
}
```

**Create:** `src/lib/ats/greenhouse.ts` (similar structure, Greenhouse-specific logic)

```typescript
import type { DetectionResult, ATSDetector } from '@/types/ats';
import {
  ATS_URL_PATTERNS,
  ATS_DOM_SIGNATURES,
  ATS_DATA_ATTRIBUTES,
  DETECTION_WEIGHTS,
  CONFIDENCE_THRESHOLDS,
} from '@/constants/ats-patterns';

export const greenhouseDetector: ATSDetector = {
  platform: 'greenhouse',

  async detect(url: string, document: Document): Promise<DetectionResult> {
    let confidence = 0;
    const signals: DetectionResult['signals'] = [];

    // URL pattern matching (30% weight)
    if (checkGreenhouseURL(url)) {
      confidence += DETECTION_WEIGHTS.url;
      signals.push('url');
    }

    // DOM signatures (40% weight)
    if (checkGreenhouseDOM(document)) {
      confidence += DETECTION_WEIGHTS.dom;
      signals.push('dom');
    }

    // Data attributes (20% weight)
    if (checkGreenhouseAttributes(document)) {
      confidence += DETECTION_WEIGHTS.attributes;
      signals.push('attributes');
    }

    // Note: Greenhouse doesn't use Shadow DOM, so no shadow signal

    const level = getConfidenceLevel(confidence);

    return {
      platform: confidence >= CONFIDENCE_THRESHOLDS.medium ? 'greenhouse' : null,
      confidence,
      signals,
      level,
      timestamp: Date.now(),
    };
  },

  findFormContainers(document: Document): HTMLElement[] {
    const containers: HTMLElement[] = [];
    const signatures = ATS_DOM_SIGNATURES.greenhouse.containers;

    for (const selector of signatures) {
      const elements = document.querySelectorAll(selector);
      containers.push(...Array.from(elements) as HTMLElement[]);
    }

    return containers;
  },
};

// Helper functions (similar to Workday but Greenhouse-specific)
function checkGreenhouseURL(url: string): boolean {
  const patterns = ATS_URL_PATTERNS.greenhouse;
  const urlObj = new URL(url);
  const hostMatch = patterns.hosts.some((host) => urlObj.hostname.includes(host));
  const pathMatch = patterns.paths.some((path) => urlObj.pathname.includes(path));
  return hostMatch && pathMatch;
}

function checkGreenhouseDOM(document: Document): boolean {
  const signatures = ATS_DOM_SIGNATURES.greenhouse;
  const hasContainers = signatures.containers.some((s) => document.querySelector(s) !== null);
  const hasMarkers = signatures.markers.some((s) => document.querySelector(s) !== null);
  return hasContainers || hasMarkers;
}

function checkGreenhouseAttributes(document: Document): boolean {
  const patterns = ATS_DATA_ATTRIBUTES.greenhouse;
  for (const attr of patterns.attributes) {
    const elements = document.querySelectorAll(`[${attr}]`);
    for (const element of elements) {
      const value = element.getAttribute(attr);
      if (value && patterns.values) {
        const expectedValue = patterns.values[attr];
        if (expectedValue instanceof RegExp && expectedValue.test(value)) {
          return true;
        }
      }
    }
  }
  return false;
}

function getConfidenceLevel(confidence: number): DetectionResult['level'] {
  if (confidence >= CONFIDENCE_THRESHOLDS.high) return 'high';
  if (confidence >= CONFIDENCE_THRESHOLDS.medium) return 'medium';
  return 'low';
}
```

**Create:** `src/lib/ats/lever.ts` (similar structure, Lever-specific logic)

```typescript
import type { DetectionResult, ATSDetector } from '@/types/ats';
import {
  ATS_URL_PATTERNS,
  ATS_DOM_SIGNATURES,
  ATS_DATA_ATTRIBUTES,
  DETECTION_WEIGHTS,
  CONFIDENCE_THRESHOLDS,
} from '@/constants/ats-patterns';

export const leverDetector: ATSDetector = {
  platform: 'lever',

  async detect(url: string, document: Document): Promise<DetectionResult> {
    let confidence = 0;
    const signals: DetectionResult['signals'] = [];

    if (checkLeverURL(url)) {
      confidence += DETECTION_WEIGHTS.url;
      signals.push('url');
    }

    if (checkLeverDOM(document)) {
      confidence += DETECTION_WEIGHTS.dom;
      signals.push('dom');
    }

    if (checkLeverAttributes(document)) {
      confidence += DETECTION_WEIGHTS.attributes;
      signals.push('attributes');
    }

    const level = getConfidenceLevel(confidence);

    return {
      platform: confidence >= CONFIDENCE_THRESHOLDS.medium ? 'lever' : null,
      confidence,
      signals,
      level,
      timestamp: Date.now(),
    };
  },

  findFormContainers(document: Document): HTMLElement[] {
    const containers: HTMLElement[] = [];
    const signatures = ATS_DOM_SIGNATURES.lever.containers;

    for (const selector of signatures) {
      const elements = document.querySelectorAll(selector);
      containers.push(...Array.from(elements) as HTMLElement[]);
    }

    return containers;
  },
};

// Helper functions (similar pattern)
function checkLeverURL(url: string): boolean {
  const patterns = ATS_URL_PATTERNS.lever;
  const urlObj = new URL(url);
  const hostMatch = patterns.hosts.some((host) => urlObj.hostname.includes(host));
  const pathMatch = patterns.paths.some((path) => urlObj.pathname.includes(path));
  return hostMatch && pathMatch;
}

function checkLeverDOM(document: Document): boolean {
  const signatures = ATS_DOM_SIGNATURES.lever;
  const hasContainers = signatures.containers.some((s) => document.querySelector(s) !== null);
  const hasMarkers = signatures.markers.some((s) => document.querySelector(s) !== null);
  return hasContainers || hasMarkers;
}

function checkLeverAttributes(document: Document): boolean {
  const patterns = ATS_DATA_ATTRIBUTES.lever;
  for (const attr of patterns.attributes) {
    const elements = document.querySelectorAll(`[${attr}]`);
    for (const element of elements) {
      const value = element.getAttribute(attr);
      if (value && patterns.values) {
        const expectedValue = patterns.values[attr];
        if (expectedValue instanceof RegExp && expectedValue.test(value)) {
          return true;
        }
      }
    }
  }
  return false;
}

function getConfidenceLevel(confidence: number): DetectionResult['level'] {
  if (confidence >= CONFIDENCE_THRESHOLDS.high) return 'high';
  if (confidence >= CONFIDENCE_THRESHOLDS.medium) return 'medium';
  return 'low';
}
```

**Commit:** `feat(02-01): implement platform-specific detectors`

---

### Task 4: Create Main Detection Orchestrator (10 min)

**Create:** `src/lib/ats/detector.ts`

```typescript
import type { DetectionResult, ATSDetector, ATSType } from '@/types/ats';
import { workdayDetector } from './workday';
import { greenhouseDetector } from './greenhouse';
import { leverDetector } from './lever';

/**
 * All registered ATS detectors
 */
const detectors: ATSDetector[] = [
  workdayDetector,
  greenhouseDetector,
  leverDetector,
];

/**
 * Detect ATS platform on current page
 * Runs all platform detectors and returns the one with highest confidence
 *
 * @param url - Current page URL
 * @param document - Current page document
 * @returns Detection result with highest confidence, or null if no detection
 */
export async function detectATS(
  url: string,
  document: Document
): Promise<DetectionResult> {
  const results = await Promise.all(
    detectors.map((detector) => detector.detect(url, document))
  );

  // Find result with highest confidence
  const bestResult = results.reduce((best, current) => {
    return current.confidence > best.confidence ? current : best;
  }, results[0]);

  return bestResult;
}

/**
 * Get detector for specific platform
 */
export function getDetector(platform: ATSType): ATSDetector | undefined {
  return detectors.find((d) => d.platform === platform);
}

/**
 * Find form containers on page using detected platform
 */
export function findFormContainers(
  platform: ATSType,
  document: Document
): HTMLElement[] {
  const detector = getDetector(platform);
  if (!detector) return [];
  return detector.findFormContainers(document);
}

/**
 * Export all detectors for testing
 */
export { workdayDetector, greenhouseDetector, leverDetector };
```

**Commit:** `feat(02-01): create main detection orchestrator`

---

## Verification Checklist

After completing all tasks, verify:

- [ ] All TypeScript files compile without errors (`pnpm type-check`)
- [ ] ESLint passes with no warnings (`pnpm lint`)
- [ ] All detector functions return proper DetectionResult structure
- [ ] Confidence scoring uses correct weights (URL 30%, DOM 40%, Attr 20%, Shadow 10%)
- [ ] Workday detector checks for Shadow DOM
- [ ] Greenhouse and Lever detectors work without Shadow DOM
- [ ] findFormContainers returns HTMLElement arrays
- [ ] All constants are properly exported from ats-patterns.ts

---

## Success Criteria

- ✅ Type system defines all ATS detection interfaces
- ✅ URL patterns and DOM signatures defined for all 3 platforms
- ✅ Platform-specific detectors implemented (Workday, Greenhouse, Lever)
- ✅ Main detector orchestrates all platform detectors
- ✅ Multi-signal detection with confidence scoring (30/40/20/10 weights)
- ✅ Code follows AGENTS.md style guide (kebab-case files, PascalCase types, camelCase functions)

---

## Next Steps

After completing this plan:
1. Commit all changes with atomic commits (1 per task)
2. Move to Plan 02-02: Content Script Infrastructure
3. Integrate detection logic into content scripts with WXT framework

---

*Plan: 02-01-ATS-Detection-Foundation*
*Priority: P0*
*Duration: 60 minutes*
