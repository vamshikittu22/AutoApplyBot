---
phase: 02-ats-detection-autofill
plan: 02
type: execute
wave: 2
depends_on: ['02-01']
files_modified:
  - src/entrypoints/background.ts
  - src/entrypoints/content/ats-detector.content.ts
  - src/lib/ats/shadow-dom-utils.ts
  - src/lib/ats/form-observer.ts
autonomous: true

must_haves:
  truths:
    - "Content script only loads on ATS pages using declarativeContent"
    - "Detection works on Shadow DOM (Workday)"
    - "MutationObserver detects dynamically loaded forms"
    - "SPA navigation triggers re-detection"
  artifacts:
    - path: "src/entrypoints/background.ts"
      provides: "declarativeContent rules for lazy content script injection"
      exports: []
      min_lines: 50
    - path: "src/entrypoints/content/ats-detector.content.ts"
      provides: "Main ATS detection content script with SPA handling"
      exports: []
      min_lines: 150
    - path: "src/lib/ats/shadow-dom-utils.ts"
      provides: "Shadow DOM traversal utilities for Workday"
      exports: ["traverseShadowDOM", "querySelectorDeep"]
      min_lines: 80
    - path: "src/lib/ats/form-observer.ts"
      provides: "MutationObserver wrapper for dynamic form detection"
      exports: ["FormObserver"]
      min_lines: 100
  key_links:
    - from: "src/entrypoints/content/ats-detector.content.ts"
      to: "@/lib/ats/detector"
      via: "Uses detectATS function"
      pattern: "detectATS"
    - from: "src/lib/ats/form-observer.ts"
      to: "@/lib/ats/detector"
      via: "Triggers detection on DOM changes"
      pattern: "detectATS"
---

<objective>
Build content script infrastructure for lazy ATS detection with Shadow DOM and SPA support.

**Purpose:** Set up WXT content scripts that only load on ATS pages, handle Shadow DOM traversal (Workday), and detect dynamically loaded forms using MutationObserver (REQ-ATS-04, REQ-ATS-05, REQ-ATS-06).

**Output:** Content scripts that load lazily, work with Shadow DOM, detect dynamic forms, and handle SPA navigation without context invalidation errors.
</objective>

<execution_context>
@C:/Users/kittu/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/kittu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-ats-detection-autofill/02-00-OVERVIEW.md
@.planning/phases/02-ats-detection-autofill/02-01-PLAN.md
@TECHSTACK.md
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Background Service Worker</name>
  <files>src/entrypoints/background.ts</files>
  <action>
Update `src/entrypoints/background.ts` to set up declarativeContent rules for lazy content script injection:

**Implementation approach:**
- Use chrome.declarativeContent API to register URL pattern rules
- Register rules for Workday, Greenhouse, and Lever URL patterns
- Only inject content script when URL matches ATS patterns
- Handle rule registration on extension install/update

```typescript
import { defineBackground } from 'wxt/sandbox';

export default defineBackground({
  type: 'module',
  main() {
    console.log('[AutoApply] Background service worker started');

    // Set up declarativeContent rules on install
    chrome.runtime.onInstalled.addListener(async () => {
      await setupDeclarativeContent();
    });
  },
});

/**
 * Configure declarativeContent rules for lazy content script injection
 * Only inject content scripts on pages matching ATS URL patterns
 */
async function setupDeclarativeContent() {
  // Remove existing rules
  await chrome.declarativeContent.onPageChanged.removeRules();

  // Define ATS URL patterns from constants
  const atsUrlPatterns = [
    // Workday
    '*://*/myworkdayjobs/*',
    '*://*/myworkday.com/*',
    '*://*.myworkdayjobs.com/*',
    '*://*.myworkday.com/*',
    // Greenhouse
    '*://boards.greenhouse.io/*',
    '*://*.greenhouse.io/*',
    '*://*/embed/job_app*',
    // Lever
    '*://jobs.lever.co/*',
    '*://*.lever.co/*',
    '*://*/apply/*',
  ];

  // Create page state matcher for ATS URLs
  const atsPageStateMatcher = {
    pageUrl: {
      urlMatches: atsUrlPatterns.join('|'),
    },
  };

  // Create rules to show page action icon on ATS pages
  const rules = [
    {
      conditions: [
        new chrome.declarativeContent.PageStateMatcher(atsPageStateMatcher),
      ],
      actions: [new chrome.declarativeContent.ShowAction()],
    },
  ];

  await chrome.declarativeContent.onPageChanged.addRules(rules);
  console.log('[AutoApply] declarativeContent rules registered');
}

/**
 * Handle messages from content scripts
 */
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('[AutoApply] Message received:', message);

  if (message.type === 'ATS_DETECTED') {
    console.log('[AutoApply] ATS detected:', message.payload);
    // Store detection result for popup
    chrome.storage.local.set({
      lastDetection: {
        url: sender.url,
        platform: message.payload.platform,
        confidence: message.payload.confidence,
        timestamp: Date.now(),
      },
    });
  }

  sendResponse({ success: true });
  return true;
});
```

**Verification:**
- Background service worker logs startup message
- declarativeContent rules registered on install
- Extension icon visible on ATS pages only
- Messages from content scripts handled correctly

**Commit:** `feat(02-02): configure background service worker with declarativeContent`
  </action>
</task>

<task type="auto">
  <name>Task 2: Create Shadow DOM Utilities</name>
  <files>src/lib/ats/shadow-dom-utils.ts</files>
  <action>
Create `src/lib/ats/shadow-dom-utils.ts` for traversing Shadow DOM (required for Workday):

**Implementation approach:**
- Implement recursive Shadow DOM traversal
- Create querySelectorDeep that searches through Shadow boundaries
- Handle multiple levels of nested Shadow DOM
- Provide getAllShadowRoots utility

```typescript
/**
 * Shadow DOM traversal utilities for ATS detection
 * Required for Workday which uses Shadow DOM extensively
 */

/**
 * Recursively find all shadow roots in the document
 */
export function getAllShadowRoots(root: Document | ShadowRoot = document): ShadowRoot[] {
  const shadowRoots: ShadowRoot[] = [];
  
  // Find all elements with shadow roots
  const walker = document.createTreeWalker(
    root as Node,
    NodeFilter.SHOW_ELEMENT,
    null
  );

  let node: Node | null = walker.currentNode;
  while (node) {
    if (node instanceof Element && node.shadowRoot) {
      shadowRoots.push(node.shadowRoot);
      // Recursively find shadow roots inside this shadow root
      shadowRoots.push(...getAllShadowRoots(node.shadowRoot));
    }
    node = walker.nextNode();
  }

  return shadowRoots;
}

/**
 * Query selector that searches through Shadow DOM boundaries
 * Similar to querySelectorAll but works with Shadow DOM
 */
export function querySelectorDeep(
  selector: string,
  root: Document | Element | ShadowRoot = document
): Element[] {
  const results: Element[] = [];

  // Search in current context
  const elements = root.querySelectorAll(selector);
  results.push(...Array.from(elements));

  // Search in shadow roots
  const shadowRoots = getAllShadowRoots(root as Document);
  for (const shadowRoot of shadowRoots) {
    const shadowElements = shadowRoot.querySelectorAll(selector);
    results.push(...Array.from(shadowElements));
  }

  return results;
}

/**
 * Traverse Shadow DOM tree and apply callback to each element
 */
export function traverseShadowDOM(
  callback: (element: Element) => void,
  root: Document | Element | ShadowRoot = document
): void {
  const walker = document.createTreeWalker(
    root as Node,
    NodeFilter.SHOW_ELEMENT,
    null
  );

  let node: Node | null = walker.currentNode;
  while (node) {
    if (node instanceof Element) {
      callback(node);

      // Traverse shadow root if present
      if (node.shadowRoot) {
        traverseShadowDOM(callback, node.shadowRoot);
      }
    }
    node = walker.nextNode();
  }
}

/**
 * Find element in Shadow DOM by attribute
 */
export function findByAttributeDeep(
  attribute: string,
  value?: string,
  root: Document | Element | ShadowRoot = document
): Element | null {
  // Try regular query first
  const selector = value ? `[${attribute}="${value}"]` : `[${attribute}]`;
  const element = root.querySelector(selector);
  if (element) return element;

  // Search in shadow roots
  const shadowRoots = getAllShadowRoots(root as Document);
  for (const shadowRoot of shadowRoots) {
    const shadowElement = shadowRoot.querySelector(selector);
    if (shadowElement) return shadowElement;
  }

  return null;
}

/**
 * Check if element is inside Shadow DOM
 */
export function isInShadowDOM(element: Element): boolean {
  let parent = element.parentNode;
  while (parent) {
    if (parent instanceof ShadowRoot) {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
}

/**
 * Get the closest shadow host element
 */
export function getShadowHost(element: Element): Element | null {
  let parent = element.parentNode;
  while (parent) {
    if (parent instanceof ShadowRoot) {
      return parent.host;
    }
    parent = parent.parentNode;
  }
  return null;
}
```

**Verification:**
- querySelectorDeep finds elements in Shadow DOM
- traverseShadowDOM visits all elements including shadowed ones
- getAllShadowRoots returns all shadow roots recursively
- Helper functions handle edge cases (no shadow root, nested shadow roots)

**Commit:** `feat(02-02): create shadow dom traversal utilities`
  </action>
</task>

<task type="auto">
  <name>Task 3: Create MutationObserver Wrapper</name>
  <files>src/lib/ats/form-observer.ts</files>
  <action>
Create `src/lib/ats/form-observer.ts` for observing dynamic form changes:

**Implementation approach:**
- Wrap MutationObserver with form-specific logic
- Debounce detection to avoid excessive re-runs
- Scope observer to form containers only (not entire document)
- Handle SPA navigation and disconnection

```typescript
import { detectATS } from './detector';
import type { DetectionResult } from '@/types/ats';

/**
 * MutationObserver wrapper for detecting dynamically loaded forms
 * Scoped to form containers only to minimize performance impact
 */
export class FormObserver {
  private observer: MutationObserver | null = null;
  private debounceTimer: ReturnType<typeof setTimeout> | null = null;
  private lastDetection: DetectionResult | null = null;
  private onDetectionChange: ((result: DetectionResult) => void) | null = null;

  /**
   * Start observing for form changes
   * @param root - Root element to observe (defaults to document.body)
   * @param callback - Called when detection result changes
   */
  start(
    root: HTMLElement = document.body,
    callback?: (result: DetectionResult) => void
  ): void {
    if (this.observer) {
      console.warn('[FormObserver] Already observing, disconnecting first');
      this.stop();
    }

    this.onDetectionChange = callback ?? null;

    // Create observer
    this.observer = new MutationObserver((mutations) => {
      this.handleMutations(mutations);
    });

    // Observe with focused config (forms and inputs only)
    this.observer.observe(root, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [
        'data-automation-id',
        'data-qa',
        'data-lever',
        'class',
        'id',
      ],
    });

    console.log('[FormObserver] Started observing for form changes');

    // Run initial detection
    this.triggerDetection();
  }

  /**
   * Stop observing
   */
  stop(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }

    console.log('[FormObserver] Stopped observing');
  }

  /**
   * Handle mutations with debouncing
   */
  private handleMutations(mutations: MutationRecord[]): void {
    // Check if mutations are relevant (form-related)
    const isRelevant = mutations.some((mutation) => {
      if (mutation.type === 'childList') {
        // Check if added nodes contain forms or form elements
        const addedNodes = Array.from(mutation.addedNodes);
        return addedNodes.some((node) => {
          if (node instanceof Element) {
            return (
              node.matches('form, input, select, textarea') ||
              node.querySelector('form, input, select, textarea') !== null
            );
          }
          return false;
        });
      }

      if (mutation.type === 'attributes') {
        // Check if attribute change is on form-related element
        const target = mutation.target as Element;
        return target.matches('form, input, select, textarea, [role="form"]');
      }

      return false;
    });

    if (isRelevant) {
      this.triggerDetection();
    }
  }

  /**
   * Trigger detection with debouncing (300ms)
   */
  private triggerDetection(): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    this.debounceTimer = setTimeout(async () => {
      await this.runDetection();
    }, 300);
  }

  /**
   * Run detection and notify if result changed
   */
  private async runDetection(): Promise<void> {
    try {
      const result = await detectATS(window.location.href, document);

      // Check if detection result changed
      if (this.hasDetectionChanged(result)) {
        console.log('[FormObserver] Detection result changed:', result);
        this.lastDetection = result;

        if (this.onDetectionChange) {
          this.onDetectionChange(result);
        }
      }
    } catch (error) {
      console.error('[FormObserver] Detection failed:', error);
    }
  }

  /**
   * Check if detection result changed significantly
   */
  private hasDetectionChanged(newResult: DetectionResult): boolean {
    if (!this.lastDetection) return true;

    return (
      newResult.platform !== this.lastDetection.platform ||
      Math.abs(newResult.confidence - this.lastDetection.confidence) > 10
    );
  }

  /**
   * Get last detection result
   */
  getLastDetection(): DetectionResult | null {
    return this.lastDetection;
  }
}

/**
 * Create and start form observer
 */
export function createFormObserver(
  callback?: (result: DetectionResult) => void
): FormObserver {
  const observer = new FormObserver();
  observer.start(document.body, callback);
  return observer;
}
```

**Verification:**
- Observer detects new forms added to DOM
- Debouncing prevents excessive detection runs
- Observer scoped to form-related elements only
- Callback fired only when detection result changes
- stop() properly cleans up observer and timers

**Commit:** `feat(02-02): create mutation observer wrapper for dynamic forms`
  </action>
</task>

<task type="auto">
  <name>Task 4: Create Main Content Script</name>
  <files>src/entrypoints/content/ats-detector.content.ts</files>
  <action>
Create `src/entrypoints/content/ats-detector.content.ts` as the main ATS detection content script:

**Implementation approach:**
- Use WXT defineContentScript with URL pattern matching
- Handle initial page load detection
- Set up MutationObserver for dynamic forms
- Handle SPA navigation with wxt:locationchange
- Send detection results to background script
- Handle context invalidation gracefully

```typescript
import { defineContentScript } from 'wxt/sandbox';
import { detectATS } from '@/lib/ats/detector';
import { createFormObserver } from '@/lib/ats/form-observer';
import type { DetectionResult } from '@/types/ats';

export default defineContentScript({
  matches: [
    // Workday
    '*://*/myworkdayjobs/*',
    '*://*/myworkday.com/*',
    '*://*.myworkdayjobs.com/*',
    '*://*.myworkday.com/*',
    // Greenhouse
    '*://boards.greenhouse.io/*',
    '*://*.greenhouse.io/*',
    '*://*/embed/job_app*',
    // Lever
    '*://jobs.lever.co/*',
    '*://*.lever.co/*',
    '*://*/apply/*',
  ],

  main() {
    console.log('[ATS Detector] Content script loaded');

    let formObserver: ReturnType<typeof createFormObserver> | null = null;
    let lastDetectionResult: DetectionResult | null = null;

    /**
     * Run ATS detection on current page
     */
    async function runDetection() {
      try {
        const result = await detectATS(window.location.href, document);
        console.log('[ATS Detector] Detection result:', result);

        lastDetectionResult = result;

        // Send to background script
        if (result.platform) {
          await chrome.runtime.sendMessage({
            type: 'ATS_DETECTED',
            payload: {
              platform: result.platform,
              confidence: result.confidence,
              level: result.level,
              signals: result.signals,
            },
          });
        }

        // Emit custom event for other content scripts
        window.dispatchEvent(
          new CustomEvent('autoapply:ats-detected', {
            detail: result,
          })
        );
      } catch (error) {
        // Handle context invalidation gracefully
        if (
          error instanceof Error &&
          error.message.includes('Extension context invalidated')
        ) {
          console.log('[ATS Detector] Extension context invalidated, stopping');
          cleanup();
        } else {
          console.error('[ATS Detector] Detection error:', error);
        }
      }
    }

    /**
     * Initialize detection and observer
     */
    function initialize() {
      console.log('[ATS Detector] Initializing...');

      // Run initial detection
      runDetection();

      // Set up form observer for dynamic content
      formObserver = createFormObserver((result) => {
        console.log('[ATS Detector] Form observer detected change:', result);
        lastDetectionResult = result;

        // Notify other content scripts
        window.dispatchEvent(
          new CustomEvent('autoapply:ats-detected', {
            detail: result,
          })
        );
      });
    }

    /**
     * Cleanup observers
     */
    function cleanup() {
      if (formObserver) {
        formObserver.stop();
        formObserver = null;
      }
    }

    /**
     * Handle SPA navigation (wxt:locationchange)
     * Re-run detection when URL changes without page reload
     */
    function handleLocationChange() {
      console.log('[ATS Detector] Location changed, re-running detection');
      cleanup();
      initialize();
    }

    // Initialize on load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }

    // Handle SPA navigation
    // WXT provides wxt:locationchange event for SPA navigation
    window.addEventListener('wxt:locationchange', handleLocationChange);

    // Also listen for standard navigation events
    let lastUrl = window.location.href;
    const navigationObserver = new MutationObserver(() => {
      const currentUrl = window.location.href;
      if (currentUrl !== lastUrl) {
        lastUrl = currentUrl;
        handleLocationChange();
      }
    });

    navigationObserver.observe(document.body, {
      childList: true,
      subtree: true,
    });

    // Cleanup on unload
    window.addEventListener('beforeunload', cleanup);

    // Expose detection result getter for other content scripts
    (window as any).__autoApplyDetection = {
      getLastResult: () => lastDetectionResult,
      rerun: runDetection,
    };

    console.log('[ATS Detector] Initialized successfully');
  },
});
```

**Verification:**
- Content script only loads on ATS URLs (check matches patterns)
- Initial detection runs on page load
- MutationObserver detects dynamic forms
- SPA navigation triggers re-detection
- Detection results sent to background script
- Custom event emitted for other content scripts
- Context invalidation handled gracefully
- Cleanup happens on unload

**Commit:** `feat(02-02): create main ats detection content script`
  </action>
</task>

</tasks>

<verification>
- [ ] Background service worker starts and logs correctly
- [ ] declarativeContent rules registered (check chrome://extensions → inspect service worker)
- [ ] Content script loads only on ATS pages (test on Workday, Greenhouse, Lever URLs)
- [ ] Shadow DOM utilities find elements in Workday's Shadow DOM
- [ ] MutationObserver detects dynamically loaded forms
- [ ] SPA navigation triggers re-detection
- [ ] Detection results sent to background script (check storage)
- [ ] No context invalidation errors
- [ ] TypeScript compiles without errors
- [ ] ESLint passes
</verification>

<success_criteria>
- ✅ declarativeContent rules configured for all 3 ATS platforms
- ✅ Content script loads lazily (only on ATS pages)
- ✅ Shadow DOM traversal works for Workday
- ✅ MutationObserver detects dynamic forms with debouncing
- ✅ SPA navigation handled without errors
- ✅ Detection results communicated to background script
- ✅ Context invalidation handled gracefully
- ✅ No performance degradation on non-form pages
</success_criteria>

<next_steps>
After completing this plan:
1. Test on real Workday, Greenhouse, and Lever URLs
2. Verify Shadow DOM detection on Workday
3. Verify dynamic form detection (forms loaded via AJAX)
4. Move to Plan 02-03: Field Mapping Engine with Confidence Scoring
</next_steps>

---

*Plan: 02-02-Content-Script-Infrastructure*
*Priority: P0*
*Duration: 45 minutes*
